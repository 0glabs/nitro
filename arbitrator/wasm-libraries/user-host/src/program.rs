// Copyright 2022-2023, Offchain Labs, Inc.
// For license information, see https://github.com/OffchainLabs/nitro/blob/master/LICENSE

use crate::{evm_api::ApiCaller, traits::UserHost};
use arbutil::{
    evm::{js::JsEvmApi, EvmData},
    wavm, Bytes20, Bytes32, Color,
};
use eyre::{eyre, Result};
use prover::programs::prelude::*;
use std::fmt::Display;

/// The list of active programs. The current program is always the last.
///
/// Note that this data-structure may re-alloc while references to [`Program`] are held.
/// This is sound due to [`Box`] providing a level of indirection.
///
/// Normal Rust rules would suggest using a [`Vec`] of cells would be better. The issue is that,
/// should an error guard recover, this WASM will reset to an earlier state but with the current
/// memory. This means that stack unwinding won't happen, rendering these primitives unhelpful.
#[allow(clippy::vec_box)]
static mut PROGRAMS: Vec<Box<Program>> = vec![];

/// An active user program.
pub(crate) struct Program {
    /// Arguments passed via the VM.
    pub args: Vec<u8>,
    /// Output generated by the program.
    pub outs: Vec<u8>,
    /// Mechanism for calling back into Geth.
    pub evm_api: JsEvmApi<ApiCaller>,
    /// EVM Context info.
    pub evm_data: EvmData,
    /// Call configuration.
    pub config: StylusConfig,
}

impl Program {
    /// Adds a new program, making it current.
    pub fn push_new(
        args: Vec<u8>,
        evm_api: JsEvmApi<ApiCaller>,
        evm_data: EvmData,
        config: StylusConfig,
    ) {
        let program = Self {
            args,
            outs: vec![],
            evm_api,
            evm_data,
            config,
        };
        unsafe { PROGRAMS.push(Box::new(program)) }
    }

    /// Removes the current program, returning its output.
    pub fn pop() -> Vec<u8> {
        unsafe { PROGRAMS.pop().expect("no program").outs }
    }

    /// Provides a reference to the current program.
    pub fn current() -> &'static mut Self {
        unsafe { PROGRAMS.last_mut().expect("no program") }
    }
}

pub(crate) struct MemoryBoundsError;

impl From<MemoryBoundsError> for eyre::ErrReport {
    fn from(_: MemoryBoundsError) -> Self {
        eyre!("memory access out of bounds")
    }
}

impl UserHost for Program {
    type Err = eyre::ErrReport;
    type MemoryErr = MemoryBoundsError;
    type A = JsEvmApi<ApiCaller>;

    fn args(&self) -> &[u8] {
        &self.args
    }

    fn outs(&mut self) -> &mut Vec<u8> {
        &mut self.outs
    }

    fn evm_api(&mut self) -> &mut Self::A {
        &mut self.evm_api
    }

    fn evm_data(&self) -> &EvmData {
        &self.evm_data
    }

    fn evm_return_data_len(&mut self) -> &mut u32 {
        &mut self.evm_data.return_data_len
    }

    fn read_bytes20(&self, ptr: u32) -> Result<Bytes20, MemoryBoundsError> {
        // TODO: check bounds
        unsafe { Ok(wavm::read_bytes20(ptr as usize)) }
    }

    fn read_bytes32(&self, ptr: u32) -> Result<Bytes32, MemoryBoundsError> {
        // TODO: check bounds
        unsafe { Ok(wavm::read_bytes32(ptr as usize)) }
    }

    fn read_slice(&self, ptr: u32, len: u32) -> Result<Vec<u8>, MemoryBoundsError> {
        // TODO: check bounds
        unsafe { Ok(wavm::read_slice_usize(ptr as usize, len as usize)) }
    }

    fn write_u32(&mut self, ptr: u32, x: u32) -> Result<(), MemoryBoundsError> {
        unsafe { wavm::caller_store32(ptr as usize, x) };
        Ok(()) // TODO: check bounds
    }

    fn write_bytes20(&self, ptr: u32, src: Bytes20) -> Result<(), MemoryBoundsError> {
        unsafe { wavm::write_bytes20(ptr as usize, src) };
        Ok(()) // TODO: check bounds
    }

    fn write_bytes32(&self, ptr: u32, src: Bytes32) -> Result<(), MemoryBoundsError> {
        unsafe { wavm::write_bytes32(ptr as usize, src) };
        Ok(()) // TODO: check bounds
    }

    fn write_slice(&self, ptr: u32, src: &[u8]) -> Result<(), MemoryBoundsError> {
        unsafe { wavm::write_slice_usize(src, ptr as usize) }
        Ok(()) // TODO: check bounds
    }

    fn say<D: Display>(&self, text: D) {
        println!("{} {text}", "Stylus says:".yellow());
    }

    fn trace(&self, name: &str, args: &[u8], outs: &[u8], _end_ink: u64) {
        let args = hex::encode(args);
        let outs = hex::encode(outs);
        println!("Error: unexpected hostio tracing info for {name} while proving: {args}, {outs}");
    }
}

// Copyright 2022-2023, Offchain Labs, Inc.
// For license information, see https://github.com/OffchainLabs/nitro/blob/master/LICENSE

use crate::evm_api::ApiCaller;
use arbutil::{
    evm::{js::JsEvmApi, EvmData},
    pricing,
};
use prover::programs::{meter::MeteredMachine, prelude::StylusConfig};

/// The list of active programs. The current program is always the last.
///
/// Note that this data-structure may re-alloc while references to [`Program`] are held.
/// This is sound due to [`Box`] providing a level of indirection.
///
/// Normal Rust rules would suggest using a [`Vec`] of cells would be better. The issue is that,
/// should an error guard recover, this WASM will reset to an earlier state but with the current
/// memory. This means that stack unwinding won't happen, rendering these primitives unhelpful.
#[allow(clippy::vec_box)]
static mut PROGRAMS: Vec<Box<Program>> = vec![];

/// An active user program.
pub(crate) struct Program {
    /// Arguments passed via the VM.
    pub args: Vec<u8>,
    /// Output generated by the program.
    pub outs: Vec<u8>,
    /// Mechanism for calling back into Geth.
    pub evm_api: JsEvmApi<ApiCaller>,
    /// EVM Context info.
    pub evm_data: EvmData,
    /// Call configuration.
    pub config: StylusConfig,
}

impl Program {
    /// Adds a new program, making it current.
    pub fn push_new(
        args: Vec<u8>,
        evm_api: JsEvmApi<ApiCaller>,
        evm_data: EvmData,
        config: StylusConfig,
    ) {
        let program = Self {
            args,
            outs: vec![],
            evm_api,
            evm_data,
            config,
        };
        unsafe { PROGRAMS.push(Box::new(program)) }
    }

    /// Removes the current program, returning its output.
    pub fn pop() -> Vec<u8> {
        unsafe { PROGRAMS.pop().expect("no program").outs }
    }

    /// Provides a reference to the current program after paying some ink.
    pub fn start(cost: u64) -> &'static mut Self {
        let program = Self::start_free();
        program.buy_ink(pricing::HOSTIO_INK + cost).unwrap();
        program
    }

    /// Provides a reference to the current program.
    pub fn start_free() -> &'static mut Self {
        unsafe { PROGRAMS.last_mut().expect("no program") }
    }
}

{
  "language": "Solidity",
  "sources": {
    "src/bridge/Bridge.sol": {
      "content": "//\n// Copyright 2021, Offchain Labs, Inc. All rights reserved.\n// SPDX-License-Identifier: UNLICENSED\n//\n\npragma solidity ^0.8.0;\n\nimport \"./Inbox.sol\";\nimport \"./Outbox.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"./IBridge.sol\";\n\ncontract Bridge is OwnableUpgradeable, IBridge {\n    using Address for address;\n    struct InOutInfo {\n        uint256 index;\n        bool allowed;\n    }\n\n    mapping(address => InOutInfo) private allowedInboxesMap;\n    //mapping(address => InOutInfo) private allowedOutboxesMap;\n\n    address[] public allowedInboxList;\n    address[] public allowedOutboxList;\n\n    address public override activeOutbox;\n\n    // Accumulator for delayed inbox; tail represents hash of the current state; each element represents the inclusion of a new message.\n    bytes32[] public override inboxAccs;\n\n    function initialize() external initializer {\n        __Ownable_init();\n    }\n\n    function allowedInboxes(address inbox) external view override returns (bool) {\n        return allowedInboxesMap[inbox].allowed;\n    }\n\n    function allowedOutboxes(address outbox) external view override returns (bool) {\n        revert(\"NOT_IMPLEMENTED\");\n    }\n\n    function deliverMessageToInbox(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    ) external payable override returns (uint256) {\n        require(allowedInboxesMap[msg.sender].allowed, \"NOT_FROM_INBOX\");\n        return\n            addMessageToInbox(\n                kind,\n                sender,\n                block.number,\n                block.timestamp, // solhint-disable-line not-rely-on-time\n                tx.gasprice,\n                messageDataHash\n            );\n    }\n\n    function addMessageToInbox(\n        uint8 kind,\n        address sender,\n        uint256 blockNumber,\n        uint256 blockTimestamp,\n        uint256 gasPrice,\n        bytes32 messageDataHash\n    ) internal returns (uint256) {\n        uint256 count = inboxAccs.length;\n        bytes32 messageHash = Messages.messageHash(\n            kind,\n            sender,\n            blockNumber,\n            blockTimestamp,\n            count,\n            gasPrice,\n            messageDataHash\n        );\n        bytes32 prevAcc = 0;\n        if (count > 0) {\n            prevAcc = inboxAccs[count - 1];\n        }\n        inboxAccs.push(Messages.addMessageToInbox(prevAcc, messageHash));\n        emit MessageDelivered(count, prevAcc, msg.sender, kind, sender, messageDataHash, gasPrice, blockTimestamp);\n        return count;\n    }\n\n    function executeCall(\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external override returns (bool success, bytes memory returnData) {\n        revert(\"NOT_IMPLEMENTED\");\n    }\n\n    function setInbox(address inbox, bool enabled) external override onlyOwner {\n        InOutInfo storage info = allowedInboxesMap[inbox];\n        bool alreadyEnabled = info.allowed;\n        emit InboxToggle(inbox, enabled);\n        if ((alreadyEnabled && enabled) || (!alreadyEnabled && !enabled)) {\n            return;\n        }\n        if (enabled) {\n            allowedInboxesMap[inbox] = InOutInfo(allowedInboxList.length, true);\n            allowedInboxList.push(inbox);\n        } else {\n            allowedInboxList[info.index] = allowedInboxList[allowedInboxList.length - 1];\n            allowedInboxesMap[allowedInboxList[info.index]].index = info.index;\n            allowedInboxList.pop();\n            delete allowedInboxesMap[inbox];\n        }\n    }\n\n    function setOutbox(address outbox, bool enabled) external override onlyOwner {\n        revert(\"NOT_IMPLEMENTED\");\n    }\n\n    function messageCount() external view override returns (uint256) {\n        return inboxAccs.length;\n    }\n}\n"
    },
    "src/bridge/Inbox.sol": {
      "content": "//\n// Copyright 2021, Offchain Labs, Inc. All rights reserved.\n// SPDX-License-Identifier: UNLICENSED\n//\n\npragma solidity ^0.8.0;\n\nimport \"./IInbox.sol\";\nimport \"./IBridge.sol\";\n\nimport \"./Messages.sol\";\nimport \"../libraries/AddressAliasHelper.sol\";\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./Bridge.sol\";\n\ncontract Inbox is IInbox {\n    uint8 internal constant ETH_TRANSFER = 0;\n    uint8 internal constant L2_MSG = 3;\n    uint8 internal constant L1MessageType_L2FundedByL1 = 7;\n    uint8 internal constant L1MessageType_submitRetryableTx = 9;\n\n    uint8 internal constant L2MessageType_unsignedEOATx = 0;\n    uint8 internal constant L2MessageType_unsignedContractTx = 1;\n\n    IBridge public override bridge;\n\n    bool public isCreateRetryablePaused;\n    bool public shouldRewriteSender;\n\n    function initialize(IBridge _bridge) external {\n        require(address(bridge) == address(0), \"ALREADY_INIT\");\n        bridge = _bridge;\n    }\n\n    /**\n     * @notice Send a generic L2 message to the chain\n     * @dev This method is an optimization to avoid having to emit the entirety of the messageData in a log. Instead validators are expected to be able to parse the data from the transaction's input\n     * @param messageData Data of the message being sent\n     */\n    function sendL2MessageFromOrigin(bytes calldata messageData)\n        external\n        returns (uint256)\n    {\n        // solhint-disable-next-line avoid-tx-origin\n        require(msg.sender == tx.origin, \"origin only\");\n        uint256 msgNum = deliverToBridge(L2_MSG, msg.sender, keccak256(messageData));\n        emit InboxMessageDeliveredFromOrigin(msgNum);\n        return msgNum;\n    }\n\n    /**\n     * @notice Send a generic L2 message to the chain\n     * @dev This method can be used to send any type of message that doesn't require L1 validation\n     * @param messageData Data of the message being sent\n     */\n    function sendL2Message(bytes calldata messageData)\n        external\n        override\n        returns (uint256)\n    {\n        uint256 msgNum = deliverToBridge(L2_MSG, msg.sender, keccak256(messageData));\n        emit InboxMessageDelivered(msgNum, messageData);\n        return msgNum;\n    }\n\n    function sendL1FundedUnsignedTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        uint256 nonce,\n        address destAddr,\n        bytes calldata data\n    ) external payable virtual override returns (uint256) {\n        return\n            _deliverMessage(\n                L1MessageType_L2FundedByL1,\n                msg.sender,\n                abi.encodePacked(\n                    L2MessageType_unsignedEOATx,\n                    maxGas,\n                    gasPriceBid,\n                    nonce,\n                    uint256(uint160(bytes20(destAddr))),\n                    msg.value,\n                    data\n                )\n            );\n    }\n\n    function sendL1FundedContractTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        address destAddr,\n        bytes calldata data\n    ) external payable virtual override returns (uint256) {\n        return\n            _deliverMessage(\n                L1MessageType_L2FundedByL1,\n                msg.sender,\n                abi.encodePacked(\n                    L2MessageType_unsignedContractTx,\n                    maxGas,\n                    gasPriceBid,\n                    uint256(uint160(bytes20(destAddr))),\n                    msg.value,\n                    data\n                )\n            );\n    }\n\n    function sendUnsignedTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        uint256 nonce,\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external virtual override returns (uint256) {\n        return\n            _deliverMessage(\n                L2_MSG,\n                msg.sender,\n                abi.encodePacked(\n                    L2MessageType_unsignedEOATx,\n                    maxGas,\n                    gasPriceBid,\n                    nonce,\n                    uint256(uint160(bytes20(destAddr))),\n                    amount,\n                    data\n                )\n            );\n    }\n\n    function sendContractTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external virtual override returns (uint256) {\n        return\n            _deliverMessage(\n                L2_MSG,\n                msg.sender,\n                abi.encodePacked(\n                    L2MessageType_unsignedContractTx,\n                    maxGas,\n                    gasPriceBid,\n                    uint256(uint160(bytes20(destAddr))),\n                    amount,\n                    data\n                )\n            );\n    }\n\n    modifier onlyOwner() {\n        // the rollup contract owns the bridge\n        address bridgeowner = Bridge(address(bridge)).owner();\n        // we want to validate the owner of the rollup\n        //address owner = RollupBase(rollup).owner();\n        require(msg.sender == bridgeowner, \"NOT_OWNER\");\n        _;\n    }\n\n    event PauseToggled(bool enabled);\n\n    /// @notice pauses creating retryables\n    function pauseCreateRetryables() external onlyOwner {\n        require(!isCreateRetryablePaused, \"ALREADY_PAUSED\");\n        isCreateRetryablePaused = true;\n        emit PauseToggled(true);\n    }\n\n    /// @notice unpauses creating retryables\n    function unpauseCreateRetryables() external onlyOwner {\n        require(isCreateRetryablePaused, \"NOT_PAUSED\");\n        isCreateRetryablePaused = false;\n        emit PauseToggled(false);\n    }\n\n    event RewriteToggled(bool enabled);\n\n    /// @notice start rewriting addresses in eth deposits\n    function startRewriteAddress() external onlyOwner {\n        require(!shouldRewriteSender, \"ALREADY_REWRITING\");\n        shouldRewriteSender = true;\n        emit RewriteToggled(true);\n    }\n\n    /// @notice stop rewriting addresses in eth deposits\n    function stopRewriteAddress() external onlyOwner {\n        require(shouldRewriteSender, \"NOT_REWRITING\");\n        shouldRewriteSender = false;\n        emit RewriteToggled(false);\n    }\n\n    /// @notice deposit eth from L1 to L2\n    /// @dev this function should not be called inside contract constructors\n    function depositEth(uint256 maxSubmissionCost)\n        external\n        payable\n        virtual\n        override\n        returns (uint256)\n    {\n        require(!isCreateRetryablePaused, \"CREATE_RETRYABLES_PAUSED\");\n        address sender = msg.sender;\n        address destinationAddress = msg.sender;\n\n        if (shouldRewriteSender) {\n            if (!Address.isContract(sender) && tx.origin == msg.sender) {\n                // isContract check fails if this function is called during a contract's constructor.\n                // We don't adjust the address for calls coming from L1 contracts since their addresses get remapped\n                // If the caller is an EOA, we adjust the address.\n                // This is needed because unsigned messages to the L2 (such as retryables)\n                // have the L1 sender address mapped.\n                // Here we preemptively reverse the mapping for EOAs so deposits work as expected\n                sender = AddressAliasHelper.undoL1ToL2Alias(sender);\n            } else {\n                destinationAddress = AddressAliasHelper.applyL1ToL2Alias(destinationAddress);\n            }\n        }\n\n        return\n            _deliverMessage(\n                L1MessageType_submitRetryableTx,\n                sender,\n                abi.encodePacked(\n                    // the beneficiary and other refund addresses don't get rewritten by arb-os\n                    // so we use the original msg.sender value\n                    uint256(uint160(bytes20(destinationAddress))),\n                    uint256(0),\n                    msg.value,\n                    maxSubmissionCost,\n                    uint256(uint160(bytes20(destinationAddress))),\n                    uint256(uint160(bytes20(destinationAddress))),\n                    uint256(0),\n                    uint256(0),\n                    uint256(0),\n                    \"\"\n                )\n            );\n    }\n\n    /**\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\n     * @dev Advanced usage only (does not rewrite aliases for excessFeeRefundAddress and callValueRefundAddress). createRetryableTicket method is the recommended standard.\n     * @param destAddr destination L2 contract address\n     * @param l2CallValue call value for retryable L2 message\n     * @param  maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n     * @param excessFeeRefundAddress maxgas x gasprice - execution cost gets credited here on L2 balance\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n     * @param maxGas Max gas deducted from user's L2 balance to cover L2 execution\n     * @param gasPriceBid price bid for L2 execution\n     * @param data ABI encoded data of L2 message\n     * @return unique id for retryable transaction (keccak256(requestID, uint(0) )\n     */\n    function createRetryableTicketNoRefundAliasRewrite(\n        address destAddr,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        bytes calldata data\n    ) public payable virtual returns (uint256) {\n        require(!isCreateRetryablePaused, \"CREATE_RETRYABLES_PAUSED\");\n\n        return\n            _deliverMessage(\n                L1MessageType_submitRetryableTx,\n                msg.sender,\n                abi.encodePacked(\n                    uint256(uint160(bytes20(destAddr))),\n                    l2CallValue,\n                    msg.value,\n                    maxSubmissionCost,\n                    uint256(uint160(bytes20(excessFeeRefundAddress))),\n                    uint256(uint160(bytes20(callValueRefundAddress))),\n                    maxGas,\n                    gasPriceBid,\n                    data.length,\n                    data\n                )\n            );\n    }\n\n    /**\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\n     * @dev all msg.value will deposited to callValueRefundAddress on L2\n     * @param destAddr destination L2 contract address\n     * @param l2CallValue call value for retryable L2 message\n     * @param  maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n     * @param excessFeeRefundAddress maxgas x gasprice - execution cost gets credited here on L2 balance\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n     * @param maxGas Max gas deducted from user's L2 balance to cover L2 execution\n     * @param gasPriceBid price bid for L2 execution\n     * @param data ABI encoded data of L2 message\n     * @return unique id for retryable transaction (keccak256(requestID, uint(0) )\n     */\n    function createRetryableTicket(\n        address destAddr,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        bytes calldata data\n    ) external payable virtual override returns (uint256) {\n        // if a refund address is a contract, we apply the alias to it\n        // so that it can access its funds on the L2\n        // since the beneficiary and other refund addresses don't get rewritten by arb-os\n        if (shouldRewriteSender && Address.isContract(excessFeeRefundAddress)) {\n            excessFeeRefundAddress = AddressAliasHelper.applyL1ToL2Alias(excessFeeRefundAddress);\n        }\n        if (shouldRewriteSender && Address.isContract(callValueRefundAddress)) {\n            // this is the beneficiary. be careful since this is the address that can cancel the retryable in the L2\n            callValueRefundAddress = AddressAliasHelper.applyL1ToL2Alias(callValueRefundAddress);\n        }\n\n        return\n            createRetryableTicketNoRefundAliasRewrite(\n                destAddr,\n                l2CallValue,\n                maxSubmissionCost,\n                excessFeeRefundAddress,\n                callValueRefundAddress,\n                maxGas,\n                gasPriceBid,\n                data\n            );\n    }\n\n    function _deliverMessage(\n        uint8 _kind,\n        address _sender,\n        bytes memory _messageData\n    ) internal returns (uint256) {\n        uint256 msgNum = deliverToBridge(_kind, _sender, keccak256(_messageData));\n        emit InboxMessageDelivered(msgNum, _messageData);\n        return msgNum;\n    }\n\n    function deliverToBridge(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    ) internal returns (uint256) {\n        return bridge.deliverMessageToInbox{ value: msg.value }(kind, sender, messageDataHash);\n    }\n}\n"
    },
    "src/bridge/Outbox.sol": {
      "content": "//\n// Copyright 2021, Offchain Labs, Inc. All rights reserved.\n// SPDX-License-Identifier: UNLICENSED\n//\n\npragma solidity ^0.8.0;\n\ncontract Outbox {\n\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "src/bridge/IBridge.sol": {
      "content": "//\n// Copyright 2021, Offchain Labs, Inc. All rights reserved.\n// SPDX-License-Identifier: UNLICENSED\n//\n\npragma solidity ^0.8.0;\n\ninterface IBridge {\n    event MessageDelivered(\n        uint256 indexed messageIndex,\n        bytes32 indexed beforeInboxAcc,\n        address inbox,\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash,\n        uint256 gasPrice,\n        uint256 timestamp\n    );\n\n    event BridgeCallTriggered(\n        address indexed outbox,\n        address indexed destAddr,\n        uint256 amount,\n        bytes data\n    );\n\n    event InboxToggle(address indexed inbox, bool enabled);\n\n    event OutboxToggle(address indexed outbox, bool enabled);\n\n    function deliverMessageToInbox(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    ) external payable returns (uint256);\n\n    function executeCall(\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool success, bytes memory returnData);\n\n    // These are only callable by the admin\n    function setInbox(address inbox, bool enabled) external;\n\n    function setOutbox(address inbox, bool enabled) external;\n\n    // View functions\n\n    function activeOutbox() external view returns (address);\n\n    function allowedInboxes(address inbox) external view returns (bool);\n\n    function allowedOutboxes(address outbox) external view returns (bool);\n\n    function inboxAccs(uint256 index) external view returns (bytes32);\n\n    function messageCount() external view returns (uint256);\n}\n"
    },
    "src/bridge/IInbox.sol": {
      "content": "//\n// Copyright 2021, Offchain Labs, Inc. All rights reserved.\n// SPDX-License-Identifier: UNLICENSED\n//\n\npragma solidity ^0.8.0;\n\nimport \"./IBridge.sol\";\nimport \"./IMessageProvider.sol\";\n\ninterface IInbox is IMessageProvider {\n    function sendL2Message(bytes calldata messageData) external returns (uint256);\n\n    function sendUnsignedTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        uint256 nonce,\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (uint256);\n\n    function sendContractTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (uint256);\n\n    function sendL1FundedUnsignedTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        uint256 nonce,\n        address destAddr,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function sendL1FundedContractTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        address destAddr,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function createRetryableTicket(\n        address destAddr,\n        uint256 arbTxCallValue,\n        uint256 maxSubmissionCost,\n        address submissionRefundAddress,\n        address valueRefundAddress,\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function depositEth(uint256 maxSubmissionCost) external payable returns (uint256);\n\n    function bridge() external view returns (IBridge);\n}\n"
    },
    "src/bridge/Messages.sol": {
      "content": "//\n// Copyright 2021, Offchain Labs, Inc. All rights reserved.\n// SPDX-License-Identifier: UNLICENSED\n//\n\npragma solidity ^0.8.0;\n\nlibrary Messages {\n    function messageHash(\n        uint8 kind,\n        address sender,\n        uint256 blockNumber,\n        uint256 timestamp,\n        uint256 inboxSeqNum,\n        uint256 gasPriceL1,\n        bytes32 messageDataHash\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    kind,\n                    sender,\n                    blockNumber,\n                    timestamp,\n                    inboxSeqNum,\n                    gasPriceL1,\n                    messageDataHash\n                )\n            );\n    }\n\n    function addMessageToInbox(bytes32 inbox, bytes32 message) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(inbox, message));\n    }\n}\n"
    },
    "src/libraries/AddressAliasHelper.sol": {
      "content": "//\n// Copyright 2021, Offchain Labs, Inc. All rights reserved.\n// SPDX-License-Identifier: UNLICENSED\n//\n\npragma solidity ^0.8.0;\n\nlibrary AddressAliasHelper {\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\n    /// the inbox to the msg.sender viewed in the L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        l2Address = address(uint160(l1Address) + offset);\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\n    /// address in the L1 that submitted a tx to the inbox\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        l1Address = address(uint160(l2Address) - offset);\n    }\n}\n"
    },
    "src/bridge/IMessageProvider.sol": {
      "content": "//\n// Copyright 2021, Offchain Labs, Inc. All rights reserved.\n// SPDX-License-Identifier: UNLICENSED\n//\n\npragma solidity ^0.8.0;\n\ninterface IMessageProvider {\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\n\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "src/osp/OneStepProverHostIo.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"../state/Values.sol\";\nimport \"../state/Machines.sol\";\nimport \"../state/Deserialize.sol\";\nimport \"./IOneStepProver.sol\";\nimport \"../bridge/Messages.sol\";\nimport \"../bridge/IBridge.sol\";\nimport \"../bridge/ISequencerInbox.sol\";\n\ncontract OneStepProverHostIo is IOneStepProver {\n    uint256 constant LEAF_SIZE = 32;\n    uint256 constant INBOX_NUM = 2;\n\n    ISequencerInbox seqInbox;\n    IBridge delayedInbox;\n\n    constructor(ISequencerInbox _seqInbox, IBridge _delayedInbox) {\n        seqInbox = _seqInbox;\n        delayedInbox = _delayedInbox;\n    }\n\n    function setLeafByte(\n        bytes32 oldLeaf,\n        uint256 idx,\n        uint8 val\n    ) internal pure returns (bytes32) {\n        require(idx < LEAF_SIZE, \"BAD_SET_LEAF_BYTE_IDX\");\n        // Take into account that we are casting the leaf to a big-endian integer\n        uint256 leafShift = (LEAF_SIZE - 1 - idx) * 8;\n        uint256 newLeaf = uint256(oldLeaf);\n        newLeaf &= ~(0xFF << leafShift);\n        newLeaf |= uint256(val) << leafShift;\n        return bytes32(newLeaf);\n    }\n\n    function executeGetOrSetBytes32(\n        Machine memory mach,\n        Module memory mod,\n        GlobalState memory state,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal pure {\n        uint256 ptr = ValueStacks.pop(mach.valueStack).contents;\n        uint32 idx = Values.assumeI32(ValueStacks.pop(mach.valueStack));\n\n        if (idx >= GlobalStates.BYTES32_VALS_NUM) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        if (ptr + 32 > mod.moduleMemory.size || ptr % LEAF_SIZE != 0) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n\n        uint256 leafIdx = ptr / LEAF_SIZE;\n        uint256 proofOffset = 0;\n        bytes32 startLeafContents;\n        MerkleProof memory merkleProof;\n        (startLeafContents, proofOffset, merkleProof) = ModuleMemories\n            .proveLeaf(mod.moduleMemory, leafIdx, proof, proofOffset);\n\n        if (inst.opcode == Instructions.GET_GLOBAL_STATE_BYTES32) {\n            mod.moduleMemory.merkleRoot = MerkleProofs.computeRootFromMemory(\n                merkleProof,\n                leafIdx,\n                state.bytes32_vals[idx]\n            );\n        } else if (inst.opcode == Instructions.SET_GLOBAL_STATE_BYTES32) {\n            state.bytes32_vals[idx] = startLeafContents;\n        } else {\n            revert(\"BAD_GLOBAL_STATE_OPCODE\");\n        }\n    }\n\n    function executeGetU64(Machine memory mach, GlobalState memory state)\n        internal\n        pure\n    {\n        uint32 idx = Values.assumeI32(ValueStacks.pop(mach.valueStack));\n\n        if (idx >= GlobalStates.U64_VALS_NUM) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n\n        ValueStacks.push(mach.valueStack, Values.newI64(state.u64_vals[idx]));\n    }\n\n    function executeSetU64(Machine memory mach, GlobalState memory state)\n        internal\n        pure\n    {\n        uint64 val = Values.assumeI64(ValueStacks.pop(mach.valueStack));\n        uint32 idx = Values.assumeI32(ValueStacks.pop(mach.valueStack));\n\n        if (idx >= GlobalStates.U64_VALS_NUM) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n        state.u64_vals[idx] = val;\n    }\n\n    function executeReadPreImage(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata,\n        bytes calldata proof\n    ) internal pure {\n        uint256 preimageOffset = ValueStacks.pop(mach.valueStack).contents;\n        uint256 ptr = ValueStacks.pop(mach.valueStack).contents;\n        if (ptr + 32 > mod.moduleMemory.size || ptr % LEAF_SIZE != 0) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n\n        uint256 leafIdx = ptr / LEAF_SIZE;\n        uint256 proofOffset = 0;\n        bytes32 leafContents;\n        MerkleProof memory merkleProof;\n        (leafContents, proofOffset, merkleProof) = ModuleMemories.proveLeaf(\n            mod.moduleMemory,\n            leafIdx,\n            proof,\n            proofOffset\n        );\n\n        bytes memory preimage = proof[proofOffset:];\n        require(keccak256(preimage) == leafContents, \"BAD_PREIMAGE\");\n\n        uint32 i = 0;\n        for (; i < 32 && preimageOffset + i < preimage.length; i++) {\n            leafContents = setLeafByte(\n                leafContents,\n                i,\n                uint8(preimage[preimageOffset + i])\n            );\n        }\n\n        mod.moduleMemory.merkleRoot = MerkleProofs.computeRootFromMemory(\n            merkleProof,\n            leafIdx,\n            leafContents\n        );\n\n        ValueStacks.push(mach.valueStack, Values.newI32(i));\n    }\n\n    function validateSequencerInbox(uint64 msgIndex, bytes calldata message)\n        internal\n        view\n        returns (bool)\n    {\n        require(message.length >= 40, \"BAD_SEQINBOX_PROOF\");\n\n        uint64 afterDelayedMsg;\n        (afterDelayedMsg, ) = Deserialize.u64(message, 32);\n        bytes32 messageHash = keccak256(message);\n        bytes32 beforeAcc;\n        bytes32 delayedAcc;\n\n        if (msgIndex > seqInbox.batchCount()) {\n            return false;\n        }\n        if (msgIndex > 0) {\n            beforeAcc = seqInbox.inboxAccs(msgIndex - 1);\n        }\n        if (afterDelayedMsg > 0) {\n            delayedAcc = delayedInbox.inboxAccs(afterDelayedMsg - 1);\n        }\n        bytes32 acc = keccak256(\n            abi.encodePacked(beforeAcc, messageHash, delayedAcc)\n        );\n        require(acc == seqInbox.inboxAccs(msgIndex), \"BAD_SEQINBOX_MESSAGE\");\n        return true;\n    }\n\n    function validateDelayedInbox(uint64 msgIndex, bytes calldata message)\n        internal\n        view\n        returns (bool)\n    {\n        if (msgIndex > delayedInbox.messageCount()) {\n            return false;\n        }\n        require(message.length >= 161, \"BAD_DELAYED_PROOF\");\n\n        bytes32 beforeAcc;\n\n        if (msgIndex > 0) {\n            beforeAcc = delayedInbox.inboxAccs(msgIndex - 1);\n        }\n\n        bytes32 messageDataHash = keccak256(message[161:]);\n        bytes1 kind = message[0];\n        uint256 sender;\n        (sender, ) = Deserialize.u256(message, 1);\n\n        bytes32 messageHash = keccak256(\n            abi.encodePacked(\n                kind,\n                uint160(sender),\n                message[33:161],\n                messageDataHash\n            )\n        );\n        bytes32 acc = Messages.addMessageToInbox(beforeAcc, messageHash);\n\n        require(acc == delayedInbox.inboxAccs(msgIndex), \"BAD_DELAYED_MESSAGE\");\n        return true;\n    }\n\n    function executeReadInboxMessage(\n        ExecutionContext calldata execCtx,\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal view {\n        uint256 messageOffset = ValueStacks.pop(mach.valueStack).contents;\n        uint256 ptr = ValueStacks.pop(mach.valueStack).contents;\n        uint256 msgIndex = ValueStacks.pop(mach.valueStack).contents;\n        if (inst.argumentData == Instructions.INBOX_INDEX_SEQUENCER && msgIndex >= execCtx.maxInboxMessagesRead) {\n            mach.status = MachineStatus.TOO_FAR;\n            return;\n        }\n\n        if (ptr + 32 > mod.moduleMemory.size || ptr % LEAF_SIZE != 0) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n\n        uint256 leafIdx = ptr / LEAF_SIZE;\n        uint256 proofOffset = 0;\n        bytes32 leafContents;\n        MerkleProof memory merkleProof;\n        (leafContents, proofOffset, merkleProof) = ModuleMemories.proveLeaf(\n            mod.moduleMemory,\n            leafIdx,\n            proof,\n            proofOffset\n        );\n\n        {\n            function(uint64, bytes calldata)\n                internal\n                view\n                returns (bool) inboxValidate;\n\n            bool success;\n            if (inst.argumentData == Instructions.INBOX_INDEX_SEQUENCER) {\n                inboxValidate = validateSequencerInbox;\n            } else if (inst.argumentData == Instructions.INBOX_INDEX_DELAYED) {\n                inboxValidate = validateDelayedInbox;\n            } else {\n                mach.status = MachineStatus.ERRORED;\n                return;\n            }\n            success = inboxValidate(uint64(msgIndex), proof[proofOffset:]);\n            if (!success) {\n                mach.status = MachineStatus.ERRORED;\n                return;\n            }\n        }\n\n        require(proof.length >= proofOffset, \"BAD_MESSAGE_PROOF\");\n        uint256 messageLength = proof.length - proofOffset;\n\n        uint32 i = 0;\n        for (; i < 32 && messageOffset + i < messageLength; i++) {\n            leafContents = setLeafByte(\n                leafContents,\n                i,\n                uint8(proof[proofOffset + messageOffset + i])\n            );\n        }\n\n        mod.moduleMemory.merkleRoot = MerkleProofs.computeRootFromMemory(\n            merkleProof,\n            leafIdx,\n            leafContents\n        );\n        ValueStacks.push(mach.valueStack, Values.newI32(i));\n    }\n\n    function executeHaltAndSetFinished(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory,\n        Instruction calldata,\n        bytes calldata\n    ) internal pure {\n        mach.status = MachineStatus.FINISHED;\n    }\n\n    function executeGlobalStateAccess(\n        ExecutionContext calldata,\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal pure {\n        uint16 opcode = inst.opcode;\n\n        GlobalState memory state;\n        uint256 proofOffset = 0;\n        (state, proofOffset) = Deserialize.globalState(proof, proofOffset);\n        require(\n            GlobalStates.hash(state) == mach.globalStateHash,\n            \"BAD_GLOBAL_STATE\"\n        );\n\n        if (\n            opcode == Instructions.GET_GLOBAL_STATE_BYTES32 ||\n            opcode == Instructions.SET_GLOBAL_STATE_BYTES32\n        ) {\n            executeGetOrSetBytes32(mach, mod, state, inst, proof[proofOffset:]);\n        } else if (opcode == Instructions.GET_GLOBAL_STATE_U64) {\n            executeGetU64(mach, state);\n        } else if (opcode == Instructions.SET_GLOBAL_STATE_U64) {\n            executeSetU64(mach, state);\n        } else {\n            revert(\"INVALID_GLOBALSTATE_OPCODE\");\n        }\n\n        mach.globalStateHash = GlobalStates.hash(state);\n    }\n\n    function executeOneStep(\n        ExecutionContext calldata execCtx,\n        Machine calldata startMach,\n        Module calldata startMod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) external view override returns (Machine memory mach, Module memory mod) {\n        mach = startMach;\n        mod = startMod;\n\n        uint16 opcode = inst.opcode;\n\n        function(\n            ExecutionContext calldata,\n            Machine memory,\n            Module memory,\n            Instruction calldata,\n            bytes calldata\n        ) internal view impl;\n\n        if (\n            opcode >= Instructions.GET_GLOBAL_STATE_BYTES32 &&\n            opcode <= Instructions.SET_GLOBAL_STATE_U64\n        ) {\n            impl = executeGlobalStateAccess;\n        } else if (opcode == Instructions.READ_PRE_IMAGE) {\n            impl = executeReadPreImage;\n        } else if (opcode == Instructions.READ_INBOX_MESSAGE) {\n            impl = executeReadInboxMessage;\n        } else if (opcode == Instructions.HALT_AND_SET_FINISHED) {\n            impl = executeHaltAndSetFinished;\n        } else {\n            revert(\"INVALID_MEMORY_OPCODE\");\n        }\n\n        impl(execCtx, mach, mod, inst, proof);\n    }\n}\n"
    },
    "src/state/Values.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nenum ValueType {\n\tI32,\n\tI64,\n\tF32,\n\tF64,\n\tREF_NULL,\n\tFUNC_REF,\n\tINTERNAL_REF,\n\tSTACK_BOUNDARY\n}\n\nstruct Value {\n\tValueType valueType;\n\tuint256 contents;\n}\n\nlibrary Values {\n\tfunction hash(Value memory val) internal pure returns (bytes32) {\n\t\treturn keccak256(abi.encodePacked(\"Value:\", val.valueType, val.contents));\n\t}\n\n\tfunction maxValueType() internal pure returns (ValueType) {\n\t\treturn ValueType.STACK_BOUNDARY;\n\t}\n\n\tfunction isNumeric(ValueType val) internal pure returns (bool) {\n\t\treturn val == ValueType.I32 || val == ValueType.I64 || val == ValueType.F32 || val == ValueType.F64;\n\t}\n\n\tfunction isNumeric(Value memory val) internal pure returns (bool) {\n\t\treturn isNumeric(val.valueType);\n\t}\n\n\tfunction assumeI32(Value memory val) internal pure returns(uint32) {\n\t\tuint uintval = uint(val.contents);\n\t\trequire(val.valueType == ValueType.I32, \"NOT_I32\");\n\t\trequire(uintval < (1<<32), \"BAD_I32\");\n\t\treturn uint32(uintval);\n\t}\n\n\tfunction assumeI64(Value memory val) internal pure returns(uint64) {\n\t\tuint uintval = uint(val.contents);\n\t\trequire(val.valueType == ValueType.I64, \"NOT_I64\");\n\t\trequire(uintval < (1<<64), \"BAD_I64\");\n\t\treturn uint64(uintval);\n\t}\n\n\tfunction newRefNull() internal pure returns (Value memory) {\n\t\treturn Value({\n\t\t\tvalueType: ValueType.REF_NULL,\n\t\t\tcontents: 0\n\t\t});\n\t}\n\n\tfunction newI32(uint32 x) internal pure returns (Value memory) {\n\t\treturn Value({\n\t\t\tvalueType: ValueType.I32,\n\t\t\tcontents: uint256(x)\n\t\t});\n\t}\n\n\tfunction newI64(uint64 x) internal pure returns (Value memory) {\n\t\treturn Value({\n\t\t\tvalueType: ValueType.I64,\n\t\t\tcontents: uint256(x)\n\t\t});\n\t}\n\n\tfunction newBoolean(bool x) internal pure returns (Value memory) {\n\t\tif (x) {\n\t\t\treturn newI32(uint32(1));\n\t\t} else {\n\t\t\treturn newI32(uint32(0));\n\t\t}\n\t}\n}\n"
    },
    "src/state/Machines.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./ValueStacks.sol\";\nimport \"./PcStacks.sol\";\nimport \"./Instructions.sol\";\nimport \"./StackFrames.sol\";\n\nenum MachineStatus {\n\tRUNNING,\n\tFINISHED,\n\tERRORED,\n\tTOO_FAR\n}\n\nstruct Machine {\n\tMachineStatus status;\n\tValueStack valueStack;\n\tValueStack internalStack;\n\tPcStack blockStack;\n\tStackFrameWindow frameStack;\n\tbytes32 globalStateHash;\n\tuint32 moduleIdx;\n\tuint32 functionIdx;\n\tuint32 functionPc;\n\tbytes32 modulesRoot;\n}\n\nlibrary Machines {\n\tfunction hash(Machine memory mach) internal pure returns (bytes32) {\n\t\t// Warning: the non-running hashes are replicated in BlockChallenge\n\t\tif (mach.status == MachineStatus.RUNNING) {\n\t\t\treturn keccak256(abi.encodePacked(\n\t\t\t\t\"Machine running:\",\n\t\t\t\tValueStacks.hash(mach.valueStack),\n\t\t\t\tValueStacks.hash(mach.internalStack),\n\t\t\t\tPcStacks.hash(mach.blockStack),\n\t\t\t\tStackFrames.hash(mach.frameStack),\n\t\t\t\tmach.globalStateHash,\n\t\t\t\tmach.moduleIdx,\n\t\t\t\tmach.functionIdx,\n\t\t\t\tmach.functionPc,\n\t\t\t\tmach.modulesRoot\n\t\t\t));\n\t\t} else if (mach.status == MachineStatus.FINISHED) {\n\t\t\treturn keccak256(abi.encodePacked(\n\t\t\t\t\"Machine finished:\",\n\t\t\t\tmach.globalStateHash\n\t\t\t));\n\t\t} else if (mach.status == MachineStatus.ERRORED) {\n\t\t\treturn keccak256(abi.encodePacked(\"Machine errored:\"));\n\t\t} else if (mach.status == MachineStatus.TOO_FAR) {\n\t\t\treturn keccak256(abi.encodePacked(\"Machine too far:\"));\n\t\t} else {\n\t\t\trevert(\"BAD_MACH_STATUS\");\n\t\t}\n\t}\n}\n"
    },
    "src/state/Deserialize.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./Values.sol\";\nimport \"./ValueStacks.sol\";\nimport \"./PcStacks.sol\";\nimport \"./Machines.sol\";\nimport \"./Instructions.sol\";\nimport \"./StackFrames.sol\";\nimport \"./MerkleProofs.sol\";\nimport \"./ModuleMemories.sol\";\nimport \"./Modules.sol\";\nimport \"./GlobalStates.sol\";\n\nlibrary Deserialize {\n\tfunction u8(bytes calldata proof, uint256 startOffset) internal pure returns (uint8 ret, uint256 offset) {\n\t\toffset = startOffset;\n\t\tret = uint8(proof[offset]);\n\t\toffset++;\n\t}\n\n\tfunction u16(bytes calldata proof, uint256 startOffset) internal pure returns (uint16 ret, uint256 offset) {\n\t\toffset = startOffset;\n\t\tfor (uint256 i = 0; i < 16/8; i++) {\n\t\t\tret <<= 8;\n\t\t\tret |= uint8(proof[offset]);\n\t\t\toffset++;\n\t\t}\n\t}\n\n\tfunction u32(bytes calldata proof, uint256 startOffset) internal pure returns (uint32 ret, uint256 offset) {\n\t\toffset = startOffset;\n\t\tfor (uint256 i = 0; i < 32/8; i++) {\n\t\t\tret <<= 8;\n\t\t\tret |= uint8(proof[offset]);\n\t\t\toffset++;\n\t\t}\n\t}\n\n\tfunction u64(bytes calldata proof, uint256 startOffset) internal pure returns (uint64 ret, uint256 offset) {\n\t\toffset = startOffset;\n\t\tfor (uint256 i = 0; i < 64/8; i++) {\n\t\t\tret <<= 8;\n\t\t\tret |= uint8(proof[offset]);\n\t\t\toffset++;\n\t\t}\n\t}\n\n\tfunction u256(bytes calldata proof, uint256 startOffset) internal pure returns (uint256 ret, uint256 offset) {\n\t\toffset = startOffset;\n\t\tfor (uint256 i = 0; i < 256/8; i++) {\n\t\t\tret <<= 8;\n\t\t\tret |= uint8(proof[offset]);\n\t\t\toffset++;\n\t\t}\n\t}\n\n\tfunction b32(bytes calldata proof, uint256 startOffset) internal pure returns (bytes32 ret, uint256 offset) {\n\t\toffset = startOffset;\n\t\tuint256 retInt;\n\t\t(retInt, offset) = u256(proof, offset);\n\t\tret = bytes32(retInt);\n\t}\n\n\tfunction value(bytes calldata proof, uint256 startOffset) internal pure returns (Value memory val, uint256 offset)  {\n\t\toffset = startOffset;\n\t\tuint8 typeInt = uint8(proof[offset]);\n\t\toffset++;\n\t\trequire(typeInt <= uint8(Values.maxValueType()), \"BAD_VALUE_TYPE\");\n\t\tuint256 contents;\n\t\t(contents, offset) = u256(proof, offset);\n\t\tval = Value({\n\t\t\tvalueType: ValueType(typeInt),\n\t\t\tcontents: contents\n\t\t});\n\t}\n\n\tfunction valueStack(bytes calldata proof, uint256 startOffset) internal pure returns (ValueStack memory stack, uint256 offset) {\n\t\toffset = startOffset;\n\t\tbytes32 remainingHash;\n\t\t(remainingHash, offset) = b32(proof, offset);\n\t\tuint256 provedLength;\n\t\t(provedLength, offset) = u256(proof, offset);\n\t\tValue[] memory proved = new Value[](provedLength);\n\t\tfor (uint256 i = 0; i < proved.length; i++) {\n\t\t\t(proved[i], offset) = value(proof, offset);\n\t\t}\n\t\tstack = ValueStack({\n\t\t\tproved: ValueArray(proved),\n\t\t\tremainingHash: remainingHash\n\t\t});\n\t}\n\n\tfunction pcStack(bytes calldata proof, uint256 startOffset) internal pure returns (PcStack memory stack, uint256 offset) {\n\t\toffset = startOffset;\n\t\tbytes32 remainingHash;\n\t\t(remainingHash, offset) = b32(proof, offset);\n\t\tuint256 provedLength;\n\t\t(provedLength, offset) = u256(proof, offset);\n\t\tuint32[] memory proved = new uint32[](provedLength);\n\t\tfor (uint256 i = 0; i < proved.length; i++) {\n\t\t\t(proved[i], offset) = u32(proof, offset);\n\t\t}\n\t\tstack = PcStack({\n\t\t\tproved: PcArray(proved),\n\t\t\tremainingHash: remainingHash\n\t\t});\n\t}\n\n\tfunction instruction(bytes calldata proof, uint256 startOffset) internal pure returns (Instruction memory inst, uint256 offset) {\n\t\toffset = startOffset;\n\t\tuint16 opcode;\n\t\tuint256 data;\n\t\t(opcode, offset) = u16(proof, offset);\n\t\t(data, offset) = u256(proof, offset);\n\t\tinst = Instruction({\n\t\t\topcode: opcode,\n\t\t\targumentData: data\n\t\t});\n\t}\n\n\tfunction stackFrame(bytes calldata proof, uint256 startOffset) internal pure returns (StackFrame memory window, uint256 offset) {\n\t\toffset = startOffset;\n\t\tValue memory returnPc;\n\t\tbytes32 localsMerkleRoot;\n\t\tuint32 callerModule;\n\t\tuint32 callerModuleInternals;\n\t\t(returnPc, offset) = value(proof, offset);\n\t\t(localsMerkleRoot, offset) = b32(proof, offset);\n\t\t(callerModule, offset) = u32(proof, offset);\n\t\t(callerModuleInternals, offset) = u32(proof, offset);\n\t\twindow = StackFrame({\n\t\t\treturnPc: returnPc,\n\t\t\tlocalsMerkleRoot: localsMerkleRoot,\n\t\t\tcallerModule: callerModule,\n\t\t\tcallerModuleInternals: callerModuleInternals\n\t\t});\n\t}\n\n\tfunction stackFrameWindow(bytes calldata proof, uint256 startOffset) internal pure returns (StackFrameWindow memory window, uint256 offset) {\n\t\toffset = startOffset;\n\t\tbytes32 remainingHash;\n\t\t(remainingHash, offset) = b32(proof, offset);\n\t\tStackFrame[] memory proved;\n\t\tif (proof[offset] != 0) {\n\t\t\toffset++;\n\t\t\tproved = new StackFrame[](1);\n\t\t\t(proved[0], offset) = stackFrame(proof, offset);\n\t\t} else {\n\t\t\toffset++;\n\t\t\tproved = new StackFrame[](0);\n\t\t}\n\t\twindow = StackFrameWindow({\n\t\t\tproved: proved,\n\t\t\tremainingHash: remainingHash\n\t\t});\n\t}\n\n\tfunction moduleMemory(bytes calldata proof, uint256 startOffset) internal pure returns (ModuleMemory memory mem, uint256 offset) {\n\t\toffset = startOffset;\n\t\tuint64 size;\n\t\tbytes32 root;\n\t\t(size, offset) = u64(proof, offset);\n\t\t(root, offset) = b32(proof, offset);\n\t\tmem = ModuleMemory({\n\t\t\tsize: size,\n\t\t\tmerkleRoot: root\n\t\t});\n\t}\n\n\tfunction module(bytes calldata proof, uint256 startOffset) internal pure returns (Module memory mod, uint256 offset) {\n\t\toffset = startOffset;\n\t\tbytes32 globalsMerkleRoot;\n\t\tModuleMemory memory mem;\n\t\tbytes32 tablesMerkleRoot;\n\t\tbytes32 functionsMerkleRoot;\n\t\tuint32 internalsOffset;\n\t\t(globalsMerkleRoot, offset) = b32(proof, offset);\n\t\t(mem, offset) = moduleMemory(proof, offset);\n\t\t(tablesMerkleRoot, offset) = b32(proof, offset);\n\t\t(functionsMerkleRoot, offset) = b32(proof, offset);\n\t\t(internalsOffset, offset) = u32(proof, offset);\n\t\tmod = Module({\n\t\t\tglobalsMerkleRoot: globalsMerkleRoot,\n\t\t\tmoduleMemory: mem,\n\t\t\ttablesMerkleRoot: tablesMerkleRoot,\n\t\t\tfunctionsMerkleRoot: functionsMerkleRoot,\n\t\t\tinternalsOffset: internalsOffset\n\t\t});\n\t}\n\n\tfunction globalState(bytes calldata proof, uint256 startOffset) internal pure returns (GlobalState memory state, uint256 offset) {\n\t\toffset = startOffset;\n\n\t\t// using constant ints for array size requires newer solidity\n\t\tbytes32[1] memory bytes32_vals;\n\t\tuint64[2] memory u64_vals;\n\n\t\tfor (uint8 i = 0; i< GlobalStates.BYTES32_VALS_NUM; i++) {\n\t\t\t(bytes32_vals[i], offset) = b32(proof, offset);\n\t\t}\n\t\tfor (uint8 i = 0; i< GlobalStates.U64_VALS_NUM; i++) {\n\t\t\t(u64_vals[i], offset) = u64(proof, offset);\n\t\t}\n\t\tstate = GlobalState({\n\t\t\tbytes32_vals: bytes32_vals,\n\t\t\tu64_vals: u64_vals\n\t\t});\n\t}\n\n\tfunction machine(bytes calldata proof, uint256 startOffset) internal pure returns (Machine memory mach, uint256 offset) {\n\t\toffset = startOffset;\n\t\tMachineStatus status;\n\t\t{\n\t\t\tuint8 status_u8;\n\t\t\t(status_u8, offset) = u8(proof, offset);\n\t\t\tif (status_u8 == 0) {\n\t\t\t\tstatus = MachineStatus.RUNNING;\n\t\t\t} else if (status_u8 == 1) {\n\t\t\t\tstatus = MachineStatus.FINISHED;\n\t\t\t} else if (status_u8 == 2) {\n\t\t\t\tstatus = MachineStatus.ERRORED;\n\t\t\t} else if (status_u8 == 3) {\n\t\t\t\tstatus = MachineStatus.TOO_FAR;\n\t\t\t} else {\n\t\t\t\trevert(\"UNKNOWN_MACH_STATUS\");\n\t\t\t}\n\t\t}\n\t\tValueStack memory values;\n\t\tValueStack memory internalStack;\n\t\tPcStack memory blocks;\n\t\tbytes32 globalStateHash;\n\t\tuint32 moduleIdx;\n\t\tuint32 functionIdx;\n\t\tuint32 functionPc;\n\t\tStackFrameWindow memory frameStack;\n\t\tbytes32 modulesRoot;\n\t\t(values, offset) = valueStack(proof, offset);\n\t\t(internalStack, offset) = valueStack(proof, offset);\n\t\t(blocks, offset) = pcStack(proof, offset);\n\t\t(frameStack, offset) = stackFrameWindow(proof, offset);\n\t\t(globalStateHash, offset) = b32(proof, offset);\n\t\t(moduleIdx, offset) = u32(proof, offset);\n\t\t(functionIdx, offset) = u32(proof, offset);\n\t\t(functionPc, offset) = u32(proof, offset);\n\t\t(modulesRoot, offset) = b32(proof, offset);\n\t\tmach = Machine({\n\t\t\tstatus: status,\n\t\t\tvalueStack: values,\n\t\t\tinternalStack: internalStack,\n\t\t\tblockStack: blocks,\n\t\t\tframeStack: frameStack,\n\t\t\tglobalStateHash: globalStateHash,\n\t\t\tmoduleIdx: moduleIdx,\n\t\t\tfunctionIdx: functionIdx,\n\t\t\tfunctionPc: functionPc,\n\t\t\tmodulesRoot: modulesRoot\n\t\t});\n\t}\n\n\tfunction merkleProof(bytes calldata proof, uint256 startOffset) internal pure returns (MerkleProof memory merkle, uint256 offset) {\n\t\toffset = startOffset;\n\t\tuint8 length;\n\t\t(length, offset) = u8(proof, offset);\n\t\tbytes32[] memory counterparts = new bytes32[](length);\n\t\tfor (uint8 i = 0; i < length; i++) {\n\t\t\t(counterparts[i], offset) = b32(proof, offset);\n\t\t}\n\t\tmerkle = MerkleProof(counterparts);\n\t}\n}\n"
    },
    "src/osp/IOneStepProver.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"../state/Machines.sol\";\nimport \"../state/Modules.sol\";\nimport \"../state/Instructions.sol\";\n\nstruct ExecutionContext {\n    uint256 maxInboxMessagesRead;\n}\n\nabstract contract IOneStepProver {\n    function executeOneStep(\n        ExecutionContext memory execCtx,\n        Machine calldata mach,\n        Module calldata mod,\n        Instruction calldata instruction,\n        bytes calldata proof\n    )\n        external\n        view\n        virtual\n        returns (Machine memory result, Module memory resultMod);\n}\n"
    },
    "src/bridge/ISequencerInbox.sol": {
      "content": "//\n// Copyright 2021, Offchain Labs, Inc. All rights reserved.\n// SPDX-License-Identifier: UNLICENSED\n//\n\npragma solidity ^0.8.0;\n\ninterface ISequencerInbox {\n    function inboxAccs(uint256 index) external view returns (bytes32);\n    function batchCount() external view returns (uint256);\n}\n"
    },
    "src/state/ValueStacks.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./Values.sol\";\nimport \"./ValueArrays.sol\";\n\nstruct ValueStack {\n\tValueArray proved;\n\tbytes32 remainingHash;\n}\n\nlibrary ValueStacks {\n\tfunction hash(ValueStack memory stack) internal pure returns (bytes32 h) {\n\t\th = stack.remainingHash;\n\t\tuint256 len = ValueArrays.length(stack.proved);\n\t\tfor (uint256 i = 0; i < len; i++) {\n\t\t\th = keccak256(abi.encodePacked(\"Value stack:\", Values.hash(ValueArrays.get(stack.proved, i)), h));\n\t\t}\n\t}\n\n\tfunction peek(ValueStack memory stack) internal pure returns (Value memory) {\n\t\tuint256 len = ValueArrays.length(stack.proved);\n\t\treturn ValueArrays.get(stack.proved, len - 1);\n\t}\n\n\tfunction pop(ValueStack memory stack) internal pure returns (Value memory) {\n\t\treturn ValueArrays.pop(stack.proved);\n\t}\n\n\tfunction push(ValueStack memory stack, Value memory val) internal pure {\n\t\treturn ValueArrays.push(stack.proved, val);\n\t}\n\n\tfunction isEmpty(ValueStack memory stack) internal pure returns (bool) {\n\t\treturn ValueArrays.length(stack.proved) == 0 && stack.remainingHash == bytes32(0);\n\t}\n\n\tfunction hasProvenDepthLessThan(ValueStack memory stack, uint256 bound) internal pure returns (bool) {\n\t\treturn ValueArrays.length(stack.proved) < bound && stack.remainingHash == bytes32(0);\n\t}\n}\n"
    },
    "src/state/PcStacks.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./PcArrays.sol\";\n\nstruct PcStack {\n\tPcArray proved;\n\tbytes32 remainingHash;\n}\n\nlibrary PcStacks {\n\tfunction hash(PcStack memory stack) internal pure returns (bytes32 h) {\n\t\th = stack.remainingHash;\n\t\tuint256 len = PcArrays.length(stack.proved);\n\t\tfor (uint256 i = 0; i < len; i++) {\n\t\t\th = keccak256(abi.encodePacked(\"Program counter stack:\", PcArrays.get(stack.proved, i), h));\n\t\t}\n\t}\n\n\tfunction pop(PcStack memory stack) internal pure returns (uint32) {\n\t\treturn PcArrays.pop(stack.proved);\n\t}\n\n\tfunction push(PcStack memory stack, uint32 val) internal pure {\n\t\treturn PcArrays.push(stack.proved, val);\n\t}\n\n\tfunction isEmpty(PcStack memory stack) internal pure returns (bool) {\n\t\treturn PcArrays.length(stack.proved) == 0 && stack.remainingHash == bytes32(0);\n\t}\n\n\tfunction hasProvenDepthLessThan(PcStack memory stack, uint256 bound) internal pure returns (bool) {\n\t\treturn PcArrays.length(stack.proved) < bound && stack.remainingHash == bytes32(0);\n\t}\n}\n"
    },
    "src/state/Instructions.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nstruct Instruction {\n    uint16 opcode;\n    uint256 argumentData;\n}\n\nlibrary Instructions {\n    uint16 constant UNREACHABLE = 0x00;\n    uint16 constant NOP = 0x01;\n    uint16 constant BLOCK = 0x02;\n    uint16 constant BRANCH = 0x0C;\n    uint16 constant BRANCH_IF = 0x0D;\n    uint16 constant RETURN = 0x0F;\n    uint16 constant CALL = 0x10;\n    uint16 constant CALL_INDIRECT = 0x11;\n    uint16 constant LOCAL_GET = 0x20;\n    uint16 constant LOCAL_SET = 0x21;\n    uint16 constant GLOBAL_GET = 0x23;\n    uint16 constant GLOBAL_SET = 0x24;\n\n    uint16 constant I32_LOAD = 0x28;\n    uint16 constant I64_LOAD = 0x29;\n    uint16 constant F32_LOAD = 0x2A;\n    uint16 constant F64_LOAD = 0x2B;\n    uint16 constant I32_LOAD8_S = 0x2C;\n    uint16 constant I32_LOAD8_U = 0x2D;\n    uint16 constant I32_LOAD16_S = 0x2E;\n    uint16 constant I32_LOAD16_U = 0x2F;\n    uint16 constant I64_LOAD8_S = 0x30;\n    uint16 constant I64_LOAD8_U = 0x31;\n    uint16 constant I64_LOAD16_S = 0x32;\n    uint16 constant I64_LOAD16_U = 0x33;\n    uint16 constant I64_LOAD32_S = 0x34;\n    uint16 constant I64_LOAD32_U = 0x35;\n\n    uint16 constant I32_STORE = 0x36;\n    uint16 constant I64_STORE = 0x37;\n    uint16 constant F32_STORE = 0x38;\n    uint16 constant F64_STORE = 0x39;\n    uint16 constant I32_STORE8 = 0x3A;\n    uint16 constant I32_STORE16 = 0x3B;\n    uint16 constant I64_STORE8 = 0x3C;\n    uint16 constant I64_STORE16 = 0x3D;\n    uint16 constant I64_STORE32 = 0x3E;\n\n    uint16 constant MEMORY_SIZE = 0x3F;\n    uint16 constant MEMORY_GROW = 0x40;\n\n    uint16 constant DROP = 0x1A;\n    uint16 constant SELECT = 0x1B;\n    uint16 constant I32_CONST = 0x41;\n    uint16 constant I64_CONST = 0x42;\n    uint16 constant F32_CONST = 0x43;\n    uint16 constant F64_CONST = 0x44;\n    uint16 constant I32_EQZ = 0x45;\n    uint16 constant I32_RELOP_BASE = 0x46;\n    uint16 constant IRELOP_EQ = 0;\n    uint16 constant IRELOP_NE = 1;\n    uint16 constant IRELOP_LT_S = 2;\n    uint16 constant IRELOP_LT_U = 3;\n    uint16 constant IRELOP_GT_S = 4;\n    uint16 constant IRELOP_GT_U = 5;\n    uint16 constant IRELOP_LE_S = 6;\n    uint16 constant IRELOP_LE_U = 7;\n    uint16 constant IRELOP_GE_S = 8;\n    uint16 constant IRELOP_GE_U = 9;\n    uint16 constant IRELOP_LAST = IRELOP_GE_U;\n\n    uint16 constant I64_EQZ = 0x50;\n    uint16 constant I64_RELOP_BASE = 0x51;\n\n    uint16 constant I32_UNOP_BASE = 0x67;\n    uint16 constant IUNOP_CLZ = 0;\n    uint16 constant IUNOP_CTZ = 1;\n    uint16 constant IUNOP_POPCNT = 2;\n    uint16 constant IUNOP_LAST = IUNOP_POPCNT;\n\n    uint16 constant I32_ADD = 0x6A;\n    uint16 constant I32_SUB = 0x6B;\n    uint16 constant I32_MUL = 0x6C;\n    uint16 constant I32_DIV_S = 0x6D;\n    uint16 constant I32_DIV_U = 0x6E;\n    uint16 constant I32_REM_S = 0x6F;\n    uint16 constant I32_REM_U = 0x70;\n    uint16 constant I32_AND = 0x71;\n    uint16 constant I32_OR = 0x72;\n    uint16 constant I32_XOR = 0x73;\n    uint16 constant I32_SHL = 0x74;\n    uint16 constant I32_SHR_S = 0x75;\n    uint16 constant I32_SHR_U = 0x76;\n    uint16 constant I32_ROTL = 0x77;\n    uint16 constant I32_ROTR = 0x78;\n\n    uint16 constant I64_UNOP_BASE = 0x79;\n\n    uint16 constant I64_ADD = 0x7C;\n    uint16 constant I64_SUB = 0x7D;\n    uint16 constant I64_MUL = 0x7E;\n    uint16 constant I64_DIV_S = 0x7F;\n    uint16 constant I64_DIV_U = 0x80;\n    uint16 constant I64_REM_S = 0x81;\n    uint16 constant I64_REM_U = 0x82;\n    uint16 constant I64_AND = 0x83;\n    uint16 constant I64_OR = 0x84;\n    uint16 constant I64_XOR = 0x85;\n    uint16 constant I64_SHL = 0x86;\n    uint16 constant I64_SHR_S = 0x87;\n    uint16 constant I64_SHR_U = 0x88;\n    uint16 constant I64_ROTL = 0x89;\n    uint16 constant I64_ROTR = 0x8A;\n\n    uint16 constant I32_WRAP_I64 = 0xA7;\n    uint16 constant I64_EXTEND_I32_S = 0xAC;\n    uint16 constant I64_EXTEND_I32_U = 0xAD;\n\n    uint16 constant I32_REINTERPRET_F32 = 0xBC;\n    uint16 constant I64_REINTERPRET_F64 = 0xBD;\n    uint16 constant F32_REINTERPRET_I32 = 0xBE;\n    uint16 constant F64_REINTERPRET_I64 = 0xBF;\n\n    uint16 constant I32_EXTEND_8S = 0xC0;\n    uint16 constant I32_EXTEND_16S = 0xC1;\n    uint16 constant I64_EXTEND_8S = 0xC2;\n    uint16 constant I64_EXTEND_16S = 0xC3;\n    uint16 constant I64_EXTEND_32S = 0xC4;\n\n    uint16 constant END_BLOCK = 0x8000;\n    uint16 constant END_BLOCK_IF = 0x8001;\n    uint16 constant INIT_FRAME = 0x8002;\n    uint16 constant ARBITRARY_JUMP_IF = 0x8003;\n    uint16 constant PUSH_STACK_BOUNDARY = 0x8004;\n    uint16 constant MOVE_FROM_STACK_TO_INTERNAL = 0x8005;\n    uint16 constant MOVE_FROM_INTERNAL_TO_STACK = 0x8006;\n    uint16 constant IS_STACK_BOUNDARY = 0x8007;\n    uint16 constant DUP = 0x8008;\n    uint16 constant CROSS_MODULE_CALL = 0x8009;\n    uint16 constant CALLER_MODULE_INTERNAL_CALL = 0x800A;\n\n    uint16 constant GET_GLOBAL_STATE_BYTES32 = 0x8010;\n    uint16 constant SET_GLOBAL_STATE_BYTES32 = 0x8011;\n    uint16 constant GET_GLOBAL_STATE_U64 = 0x8012;\n    uint16 constant SET_GLOBAL_STATE_U64 = 0x8013;\n\n    uint16 constant READ_PRE_IMAGE = 0x8020;\n    uint16 constant READ_INBOX_MESSAGE = 0x8021;\n    uint16 constant HALT_AND_SET_FINISHED = 0x8022;\n\n    uint256 constant INBOX_INDEX_SEQUENCER = 0;\n    uint256 constant INBOX_INDEX_DELAYED = 1;\n\n    function hash(Instruction memory inst) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\"Instruction:\", inst.opcode, inst.argumentData)\n            );\n    }\n\n    function newNop() internal pure returns (Instruction memory) {\n        return Instruction({opcode: NOP, argumentData: 0});\n    }\n}\n"
    },
    "src/state/StackFrames.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./Values.sol\";\n\nstruct StackFrame {\n    Value returnPc;\n    bytes32 localsMerkleRoot;\n    uint32 callerModule;\n    uint32 callerModuleInternals;\n}\n\nstruct StackFrameWindow {\n    StackFrame[] proved;\n    bytes32 remainingHash;\n}\n\nlibrary StackFrames {\n    function hash(StackFrame memory frame) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    \"Stack frame:\",\n                    Values.hash(frame.returnPc),\n                    frame.localsMerkleRoot,\n                    frame.callerModule,\n                    frame.callerModuleInternals\n                )\n            );\n    }\n\n    function hash(StackFrameWindow memory window)\n        internal\n        pure\n        returns (bytes32 h)\n    {\n        h = window.remainingHash;\n        for (uint256 i = 0; i < window.proved.length; i++) {\n            h = keccak256(\n                abi.encodePacked(\n                    \"Stack frame stack:\",\n                    hash(window.proved[i]),\n                    h\n                )\n            );\n        }\n    }\n\n    function peek(StackFrameWindow memory window)\n        internal\n        pure\n        returns (StackFrame memory)\n    {\n        require(window.proved.length == 1, \"BAD_WINDOW_LENGTH\");\n        return window.proved[0];\n    }\n\n    function pop(StackFrameWindow memory window)\n        internal\n        pure\n        returns (StackFrame memory frame)\n    {\n        require(window.proved.length == 1, \"BAD_WINDOW_LENGTH\");\n        frame = window.proved[0];\n        window.proved = new StackFrame[](0);\n    }\n\n    function push(StackFrameWindow memory window, StackFrame memory frame)\n        internal\n        pure\n    {\n        StackFrame[] memory newProved = new StackFrame[](\n            window.proved.length + 1\n        );\n        for (uint256 i = 0; i < window.proved.length; i++) {\n            newProved[i] = window.proved[i];\n        }\n        newProved[window.proved.length] = frame;\n        window.proved = newProved;\n    }\n}\n"
    },
    "src/state/ValueArrays.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./Values.sol\";\n\nstruct ValueArray {\n\tValue[] inner;\n}\n\nlibrary ValueArrays {\n\tfunction get(ValueArray memory arr, uint256 index) internal pure returns (Value memory) {\n\t\treturn arr.inner[index];\n\t}\n\n\tfunction set(ValueArray memory arr, uint256 index, Value memory val) internal pure {\n\t\tarr.inner[index] = val;\n\t}\n\n\tfunction length(ValueArray memory arr) internal pure returns (uint256) {\n\t\treturn arr.inner.length;\n\t}\n\n\tfunction push(ValueArray memory arr, Value memory val) internal pure {\n\t\tValue[] memory newInner = new Value[](arr.inner.length + 1);\n\t\tfor (uint256 i = 0; i < arr.inner.length; i++) {\n\t\t\tnewInner[i] = arr.inner[i];\n\t\t}\n\t\tnewInner[arr.inner.length] = val;\n\t\tarr.inner = newInner;\n\t}\n\n\tfunction pop(ValueArray memory arr) internal pure returns (Value memory popped) {\n\t\tpopped = arr.inner[arr.inner.length - 1];\n\t\tValue[] memory newInner = new Value[](arr.inner.length - 1);\n\t\tfor (uint256 i = 0; i < newInner.length; i++) {\n\t\t\tnewInner[i] = arr.inner[i];\n\t\t}\n\t\tarr.inner = newInner;\n\t}\n}\n"
    },
    "src/state/PcArrays.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nstruct PcArray {\n\tuint32[] inner;\n}\n\nlibrary PcArrays {\n\tfunction get(PcArray memory arr, uint256 index) internal pure returns (uint32) {\n\t\treturn arr.inner[index];\n\t}\n\n\tfunction set(PcArray memory arr, uint256 index, uint32 val) internal pure {\n\t\tarr.inner[index] = val;\n\t}\n\n\tfunction length(PcArray memory arr) internal pure returns (uint256) {\n\t\treturn arr.inner.length;\n\t}\n\n\tfunction push(PcArray memory arr, uint32 val) internal pure {\n\t\tuint32[] memory newInner = new uint32[](arr.inner.length + 1);\n\t\tfor (uint256 i = 0; i < arr.inner.length; i++) {\n\t\t\tnewInner[i] = arr.inner[i];\n\t\t}\n\t\tnewInner[arr.inner.length] = val;\n\t\tarr.inner = newInner;\n\t}\n\n\tfunction pop(PcArray memory arr) internal pure returns (uint32 popped) {\n\t\tpopped = arr.inner[arr.inner.length - 1];\n\t\tuint32[] memory newInner = new uint32[](arr.inner.length - 1);\n\t\tfor (uint256 i = 0; i < newInner.length; i++) {\n\t\t\tnewInner[i] = arr.inner[i];\n\t\t}\n\t\tarr.inner = newInner;\n\t}\n}\n"
    },
    "src/state/MerkleProofs.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./Values.sol\";\nimport \"./Instructions.sol\";\nimport \"./Modules.sol\";\n\nstruct MerkleProof {\n\tbytes32[] counterparts;\n}\n\nlibrary MerkleProofs {\n\tfunction computeRootFromValue(MerkleProof memory proof, uint256 index, Value memory leaf) internal pure returns (bytes32) {\n\t\treturn computeRootUnsafe(proof, index, Values.hash(leaf), \"Value merkle tree:\");\n\t}\n\n\tfunction computeRootFromInstruction(MerkleProof memory proof, uint256 index, Instruction memory inst) internal pure returns (bytes32) {\n\t\treturn computeRootUnsafe(proof, index, Instructions.hash(inst), \"Instruction merkle tree:\");\n\t}\n\n\tfunction computeRootFromFunction(MerkleProof memory proof, uint256 index, bytes32 codeRoot) internal pure returns (bytes32) {\n\t\tbytes32 h = keccak256(abi.encodePacked(\"Function:\", codeRoot));\n\t\treturn computeRootUnsafe(proof, index, h, \"Function merkle tree:\");\n\t}\n\n\tfunction computeRootFromMemory(MerkleProof memory proof, uint256 index, bytes32 contents) internal pure returns (bytes32) {\n\t\tbytes32 h = keccak256(abi.encodePacked(\"Memory leaf:\", contents));\n\t\treturn computeRootUnsafe(proof, index, h, \"Memory merkle tree:\");\n\t}\n\n\tfunction computeRootFromElement(MerkleProof memory proof, uint256 index, bytes32 funcTypeHash, Value memory val) internal pure returns (bytes32) {\n\t\tbytes32 h = keccak256(abi.encodePacked(\"Table element:\", funcTypeHash, Values.hash(val)));\n\t\treturn computeRootUnsafe(proof, index, h, \"Table element merkle tree:\");\n\t}\n\n\tfunction computeRootFromTable(MerkleProof memory proof, uint256 index, uint8 tableType, uint64 tableSize, bytes32 elementsRoot) internal pure returns (bytes32) {\n\t\tbytes32 h = keccak256(abi.encodePacked(\"Table:\", tableType, tableSize, elementsRoot));\n\t\treturn computeRootUnsafe(proof, index, h, \"Table merkle tree:\");\n\t}\n\n\tfunction computeRootFromModule(MerkleProof memory proof, uint256 index, Module memory mod) internal pure returns (bytes32) {\n\t\treturn computeRootUnsafe(proof, index, Modules.hash(mod), \"Module merkle tree:\");\n\t}\n\n\t// WARNING: leafHash must be computed in such a way that it cannot be a non-leaf hash.\n\tfunction computeRootUnsafe(MerkleProof memory proof, uint256 index, bytes32 leafHash, string memory prefix) internal pure returns (bytes32 h) {\n\t\th = leafHash;\n\t\tfor (uint256 layer = 0; layer < proof.counterparts.length; layer++) {\n\t\t\tif (index & 1 == 0) {\n\t\t\t\th = keccak256(abi.encodePacked(prefix, h, proof.counterparts[layer]));\n\t\t\t} else {\n\t\t\t\th = keccak256(abi.encodePacked(prefix, proof.counterparts[layer], h));\n\t\t\t}\n\t\t\tindex >>= 1;\n\t\t}\n\t}\n}\n"
    },
    "src/state/ModuleMemories.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./MerkleProofs.sol\";\nimport \"./Deserialize.sol\";\n\nstruct ModuleMemory {\n\tuint64 size;\n\tbytes32 merkleRoot;\n}\n\nlibrary ModuleMemories {\n\tfunction hash(ModuleMemory memory mem) internal pure returns (bytes32) {\n\t\treturn keccak256(abi.encodePacked(\"Memory:\", mem.size, mem.merkleRoot));\n\t}\n\n\tfunction proveLeaf(ModuleMemory memory mem, uint256 leafIdx, bytes calldata proof, uint256 startOffset) internal pure returns (bytes32 contents, uint256 offset, MerkleProof memory merkle) {\n\t\toffset = startOffset;\n\t\t(contents, offset) = Deserialize.b32(proof, offset);\n\t\t(merkle, offset) = Deserialize.merkleProof(proof, offset);\n\t\tbytes32 recomputedRoot = MerkleProofs.computeRootFromMemory(merkle, leafIdx, contents);\n\t\trequire(recomputedRoot == mem.merkleRoot, \"WRONG_MEM_ROOT\");\n\t}\n}\n"
    },
    "src/state/Modules.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./ModuleMemories.sol\";\n\nstruct Module {\n    bytes32 globalsMerkleRoot;\n    ModuleMemory moduleMemory;\n    bytes32 tablesMerkleRoot;\n    bytes32 functionsMerkleRoot;\n    uint32 internalsOffset;\n}\n\nlibrary Modules {\n    function hash(Module memory mod) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    \"Module:\",\n                    mod.globalsMerkleRoot,\n                    ModuleMemories.hash(mod.moduleMemory),\n                    mod.tablesMerkleRoot,\n                    mod.functionsMerkleRoot,\n                    mod.internalsOffset\n                )\n            );\n    }\n}\n"
    },
    "src/state/GlobalStates.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nstruct GlobalState {\n\tbytes32[1] bytes32_vals;\n\tuint64[2] u64_vals;\n}\n\n\nlibrary GlobalStates {\n\tuint16 constant BYTES32_VALS_NUM = 1;\n\tuint16 constant U64_VALS_NUM = 2;\n\tfunction hash(GlobalState memory state) internal pure returns (bytes32) {\n\t\treturn keccak256(abi.encodePacked(\n\t\t\t\"Global state:\",\n\t\t\tstate.bytes32_vals[0],\n\t\t\tstate.u64_vals[0],\n\t\t\tstate.u64_vals[1]\n\t\t));\n\t}\n}\n"
    },
    "src/bridge/SequencerInbox.sol": {
      "content": "//\n// Copyright 2021, Offchain Labs, Inc. All rights reserved.\n// SPDX-License-Identifier: UNLICENSED\n//\n\npragma solidity ^0.8.0;\n\nimport \"./IBridge.sol\";\nimport \"./ISequencerInbox.sol\";\nimport \"./Messages.sol\";\nimport \"../utils/IGasRefunder.sol\";\n\ncontract SequencerInbox is ISequencerInbox {\n\tbytes32[] public override inboxAccs;\n    uint256 public totalDelayedMessagesRead;\n\n    IBridge public delayedBridge;\n\n    mapping(address => bool) public isBatchPoster;\n    uint256 public maxDelayBlocks;\n    uint256 public maxFutureBlocks;\n    uint256 public maxDelaySeconds;\n    uint256 public maxFutureSeconds;\n\n    event SequencerBatchDelivered(\n        uint256 indexed batchSequenceNumber,\n        bytes32 indexed beforeAcc,\n        bytes32 indexed afterAcc,\n        bytes32 delayedAcc,\n        uint256 afterDelayedMessagesRead,\n        uint256[4] timeBounds,\n        bytes data\n    );\n\n    event SequencerBatchDeliveredFromOrigin(\n        uint256 indexed batchSequenceNumber,\n        bytes32 indexed beforeAcc,\n        bytes32 indexed afterAcc,\n        bytes32 delayedAcc,\n        uint256 afterDelayedMessagesRead,\n        uint256[4] timeBounds\n    );\n\n    constructor(\n        IBridge _delayedBridge,\n        address _sequencer\n    ) {\n        delayedBridge = _delayedBridge;\n        isBatchPoster[_sequencer] = true;\n\n\t\tmaxDelaySeconds = 60*60*24;\n\t\tmaxFutureSeconds = 60*60;\n\n\t\tmaxDelayBlocks = maxDelaySeconds * 15;\n\t\tmaxFutureBlocks = 12;\n    }\n\n    function getTimeBounds() internal view returns (uint256[4] memory) {\n        uint256[4] memory bounds;\n        if (block.timestamp > maxDelaySeconds) {\n            bounds[0] = block.timestamp - maxDelaySeconds;\n        } else {\n            bounds[0] = 0;\n        }\n        bounds[1] = block.timestamp + maxFutureSeconds;\n        if (block.number > maxDelayBlocks) {\n            bounds[2] = block.number - maxDelayBlocks;\n        } else {\n            bounds[2] = 0;\n        }\n        bounds[3] = block.number + maxFutureBlocks;\n        return bounds;\n    }\n\n    function forceInclusion(\n        uint256 _totalDelayedMessagesRead,\n        uint8 kind,\n        uint256[2] calldata l1BlockAndTimestamp,\n        uint256 inboxSeqNum,\n        uint256 gasPriceL1,\n        address sender,\n        bytes32 messageDataHash,\n        bytes calldata emptyData\n    ) external {\n        require(_totalDelayedMessagesRead > totalDelayedMessagesRead, \"DELAYED_BACKWARDS\");\n        {\n            bytes32 messageHash = Messages.messageHash(\n                kind,\n                sender,\n                l1BlockAndTimestamp[0],\n                l1BlockAndTimestamp[1],\n                inboxSeqNum,\n                gasPriceL1,\n                messageDataHash\n            );\n            // Can only force-include after the Sequencer-only window has expired.\n            require(l1BlockAndTimestamp[0] + maxDelayBlocks < block.number, \"MAX_DELAY_BLOCKS\");\n            require(l1BlockAndTimestamp[1] + maxDelaySeconds < block.timestamp, \"MAX_DELAY_TIME\");\n\n            // Verify that message hash represents the last message sequence of delayed message to be included\n            bytes32 prevDelayedAcc = 0;\n            if (_totalDelayedMessagesRead > 1) {\n                prevDelayedAcc = delayedBridge.inboxAccs(_totalDelayedMessagesRead - 2);\n            }\n            require(\n                delayedBridge.inboxAccs(_totalDelayedMessagesRead - 1) ==\n                    Messages.addMessageToInbox(prevDelayedAcc, messageHash),\n                \"DELAYED_ACCUMULATOR\"\n            );\n        }\n\n        require(emptyData.length == 0, \"NOT_EMPTY\");\n        (bytes32 beforeAcc, bytes32 delayedAcc, bytes32 afterAcc, uint256[4] memory timeBounds) = addSequencerL2BatchImpl(\n            emptyData,\n            _totalDelayedMessagesRead\n        );\n        emit SequencerBatchDelivered(\n            inboxAccs.length - 1,\n            beforeAcc,\n            afterAcc,\n            delayedAcc,\n            totalDelayedMessagesRead,\n            timeBounds,\n            emptyData\n        );\n    }\n\n    function addSequencerL2BatchFromOrigin(\n        uint256 sequenceNumber,\n        bytes calldata data,\n        uint256 afterDelayedMessagesRead,\n        IGasRefunder gasRefunder\n    ) external {\n        // solhint-disable-next-line avoid-tx-origin\n        require(msg.sender == tx.origin, \"ORIGIN_ONLY\");\n        require(isBatchPoster[msg.sender], \"NOT_BATCH_POSTER\");\n\n        uint256 startGasLeft = gasleft();\n        uint256 calldataSize;\n        assembly {\n            calldataSize := calldatasize()\n        }\n\n        require(inboxAccs.length == sequenceNumber, \"BAD_SEQ_NUM\");\n        (bytes32 beforeAcc, bytes32 delayedAcc, bytes32 afterAcc, uint256[4] memory timeBounds) = addSequencerL2BatchImpl(\n            data,\n            afterDelayedMessagesRead\n        );\n        emit SequencerBatchDeliveredFromOrigin(\n            inboxAccs.length - 1,\n            beforeAcc,\n            afterAcc,\n            delayedAcc,\n            totalDelayedMessagesRead,\n            timeBounds\n        );\n\n        if (address(gasRefunder) != address(0)) {\n            gasRefunder.onGasSpent(payable(msg.sender), startGasLeft - gasleft(), calldataSize);\n        }\n    }\n\n    function addSequencerL2Batch(\n        uint256 sequenceNumber,\n        bytes calldata data,\n        uint256 afterDelayedMessagesRead,\n        IGasRefunder gasRefunder\n    ) external {\n        require(isBatchPoster[msg.sender], \"NOT_BATCH_POSTER\");\n\n        uint256 startGasLeft = gasleft();\n\n        require(inboxAccs.length == sequenceNumber, \"BAD_SEQ_NUM\");\n        (bytes32 beforeAcc, bytes32 delayedAcc, bytes32 afterAcc, uint256[4] memory timeBounds) = addSequencerL2BatchImpl(\n            data,\n            afterDelayedMessagesRead\n        );\n        emit SequencerBatchDelivered(\n            inboxAccs.length - 1,\n            beforeAcc,\n            afterAcc,\n            delayedAcc,\n            afterDelayedMessagesRead,\n            timeBounds,\n            data\n        );\n\n        if (address(gasRefunder) != address(0)) {\n            uint256 calldataSize;\n            assembly {\n                calldataSize := calldatasize()\n            }\n            gasRefunder.onGasSpent(payable(msg.sender), startGasLeft - gasleft(), calldataSize);\n        }\n    }\n\n    function addSequencerL2BatchImpl(\n        bytes calldata data,\n        uint256 afterDelayedMessagesRead\n    ) internal returns (bytes32 beforeAcc, bytes32 delayedAcc, bytes32 acc, uint256[4] memory timeBounds) {\n        require(afterDelayedMessagesRead >= totalDelayedMessagesRead, \"DELAYED_BACKWARDS\");\n        require(delayedBridge.messageCount() >= afterDelayedMessagesRead, \"DELAYED_TOO_FAR\");\n\n        uint256 fullDataLen = 40 + data.length;\n        require(fullDataLen >= 40, \"DATA_LEN_OVERFLOW\");\n        bytes memory fullData = new bytes(fullDataLen);\n        bytes memory header = abi.encodePacked(\n            uint64(block.timestamp - maxDelaySeconds),\n            uint64(block.timestamp + maxFutureSeconds),\n            uint64(block.number - maxDelayBlocks),\n            uint64(block.number + maxFutureBlocks),\n            uint64(afterDelayedMessagesRead)\n        );\n        require(header.length == 40, \"BAD_HEADER_LEN\");\n        for (uint256 i = 0; i < 40; i++) {\n            fullData[i] = header[i];\n        }\n        // copy data into fullData at offset 40 (the extra 32 offset is because solidity puts the array len first)\n        assembly {\n            calldatacopy(add(fullData, 72), data.offset, data.length)\n        }\n\n        if (inboxAccs.length > 0) {\n            beforeAcc = inboxAccs[inboxAccs.length - 1];\n        }\n        if (afterDelayedMessagesRead > 0) {\n            delayedAcc = delayedBridge.inboxAccs(afterDelayedMessagesRead - 1);\n        }\n        timeBounds = getTimeBounds();\n        bytes32 fullDataHash = keccak256(fullData);\n        acc = keccak256(abi.encodePacked(beforeAcc, fullDataHash, delayedAcc, timeBounds));\n        inboxAccs.push(acc);\n        totalDelayedMessagesRead = afterDelayedMessagesRead;\n    }\n\n    function batchCount() external view override returns (uint256) {\n        return inboxAccs.length;\n    }\n}\n"
    },
    "src/utils/IGasRefunder.sol": {
      "content": "// \n// Copyright 2021, Offchain Labs, Inc. All rights reserved.\n// SPDX-License-Identifier: UNLICENSED\n//\n\npragma solidity >=0.6.11 <0.9.0;\n\ninterface IGasRefunder {\n    function onGasSpent(\n        address payable spender,\n        uint256 gasUsed,\n        uint256 calldataSize\n    ) external returns (bool success);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/beacon/UpgradeableBeacon.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../../access/Ownable.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeacon is IBeacon, Ownable {\n    address private _implementation;\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\n     * beacon.\n     */\n    constructor(address implementation_) {\n        _setImplementation(implementation_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual override returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"UpgradeableBeacon: implementation is not a contract\");\n        _implementation = newImplementation;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../Proxy.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        assert(_BEACON_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.beacon\")) - 1));\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "src/rollup/ExecutionChallenge.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"../osp/IOneStepProofEntry.sol\";\nimport \"./IChallengeResultReceiver.sol\";\nimport \"./ChallengeLib.sol\";\nimport \"./IExecutionChallenge.sol\";\nimport \"./Cloneable.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\n\ncontract ExecutionChallenge is IExecutionChallenge, Cloneable {\n    enum Turn {\n        NO_CHALLENGE,\n        ASSERTER,\n        CHALLENGER\n    }\n\n    event InitiatedChallenge();\n    event Bisected(\n        bytes32 indexed challengeRoot,\n        uint256 challengedSegmentStart,\n        uint256 challengedSegmentLength,\n        bytes32[] chainHashes\n    );\n    event AsserterTimedOut();\n    event ChallengerTimedOut();\n    event OneStepProofCompleted();\n    event ContinuedExecutionProven();\n\n    uint256 constant MAX_CHALLENGE_DEGREE = 40;\n\n    string constant NO_TURN = \"NO_TURN\";\n\n    IOneStepProofEntry public osp;\n    IChallengeResultReceiver resultReceiver;\n\n    ExecutionContext public execCtx;\n\n    bytes32 public challengeStateHash;\n\n    address public asserter;\n    address public challenger;\n\n    uint256 public asserterTimeLeft;\n    uint256 public challengerTimeLeft;\n    uint256 public lastMoveTimestamp;\n\n    Turn public turn;\n\n    constructor(\n        IOneStepProofEntry osp_,\n        IChallengeResultReceiver resultReceiver_,\n        ExecutionContext memory execCtx_,\n        bytes32 challengeStateHash_,\n        address asserter_,\n        address challenger_,\n        uint256 asserterTimeLeft_,\n        uint256 challengerTimeLeft_\n    ) {\n        osp = osp_;\n        resultReceiver = resultReceiver_;\n        execCtx = execCtx_;\n        challengeStateHash = challengeStateHash_;\n        asserter = asserter_;\n        challenger = challenger_;\n        asserterTimeLeft = asserterTimeLeft_;\n        challengerTimeLeft = challengerTimeLeft_;\n        lastMoveTimestamp = block.timestamp;\n        turn = Turn.CHALLENGER;\n\n        emit InitiatedChallenge();\n    }\n\n    modifier takeTurn() {\n        require(msg.sender == currentResponder(), \"BIS_SENDER\");\n        require(\n            block.timestamp - lastMoveTimestamp <= currentResponderTimeLeft(),\n            \"BIS_DEADLINE\"\n        );\n\n        _;\n\n        if (turn == Turn.CHALLENGER) {\n            challengerTimeLeft -= block.timestamp - lastMoveTimestamp;\n            turn = Turn.ASSERTER;\n        } else {\n            asserterTimeLeft -= block.timestamp - lastMoveTimestamp;\n            turn = Turn.CHALLENGER;\n        }\n        lastMoveTimestamp = block.timestamp;\n    }\n\n    function currentResponder() public view returns (address) {\n        if (turn == Turn.ASSERTER) {\n            return asserter;\n        } else if (turn == Turn.CHALLENGER) {\n            return challenger;\n        } else {\n            revert(NO_TURN);\n        }\n    }\n\n    function currentResponderTimeLeft() public view returns (uint256) {\n        if (turn == Turn.ASSERTER) {\n            return asserterTimeLeft;\n        } else if (turn == Turn.CHALLENGER) {\n            return challengerTimeLeft;\n        } else {\n            revert(NO_TURN);\n        }\n    }\n\n    /**\n     * @notice Initiate the next round in the bisection by objecting to execution correctness with a bisection\n     * of an execution segment with the same length but a different endpoint. This is either the initial move\n     * or follows another execution objection\n     */\n    function bisectExecution(\n        uint256 oldSegmentsStart,\n        uint256 oldSegmentsLength,\n        bytes32[] calldata oldSegments,\n        uint256 challengePosition,\n        bytes32[] calldata newSegments\n    ) external takeTurn {\n        (\n            uint256 challengeStart,\n            uint256 challengeLength\n        ) = ChallengeLib.extractChallengeSegment(\n\t\t\t\tchallengeStateHash,\n                oldSegmentsStart,\n                oldSegmentsLength,\n                oldSegments,\n                challengePosition\n            );\n\t\trequire(challengeLength > 1, \"TOO_SHORT\");\n        {\n            uint256 expectedDegree = challengeLength;\n            if (expectedDegree > MAX_CHALLENGE_DEGREE) {\n                expectedDegree = MAX_CHALLENGE_DEGREE;\n            }\n            require(expectedDegree >= 1, \"BAD_DEGREE\");\n            require(newSegments.length == expectedDegree + 1, \"WRONG_DEGREE\");\n        }\n        require(\n            newSegments[newSegments.length - 1] !=\n                oldSegments[oldSegments.length - 1],\n            \"SAME_END\"\n        );\n\n        require(oldSegments[0] == newSegments[0], \"DIFF_START\");\n\n        challengeStateHash = ChallengeLib.hashChallengeState(\n            challengeStart,\n            challengeLength,\n            newSegments\n        );\n\n        emit Bisected(\n            challengeStateHash,\n            challengeStart,\n            challengeLength,\n            newSegments\n        );\n    }\n\n    function oneStepProveExecution(\n        uint256 oldSegmentsStart,\n        uint256 oldSegmentsLength,\n        bytes32[] calldata oldSegments,\n        uint256 challengePosition,\n        bytes calldata proof\n    ) external takeTurn {\n        (uint256 challengeStart, uint256 challengeLength) = ChallengeLib.extractChallengeSegment(\n\t\t\tchallengeStateHash,\n            oldSegmentsStart,\n            oldSegmentsLength,\n            oldSegments,\n            challengePosition\n        );\n        require(challengeLength == 1, \"TOO_LONG\");\n\n        bytes32 afterHash = osp.proveOneStep(\n            execCtx,\n            challengeStart,\n            oldSegments[challengePosition],\n            proof\n        );\n        require(\n            afterHash != oldSegments[challengePosition + 1],\n            \"SAME_OSP_END\"\n        );\n\n        emit OneStepProofCompleted();\n        _currentWin();\n    }\n\n    function timeout() external {\n        uint256 timeSinceLastMove = block.timestamp - lastMoveTimestamp;\n        require(\n            timeSinceLastMove > currentResponderTimeLeft(),\n            \"TIMEOUT_DEADLINE\"\n        );\n\n        if (turn == Turn.ASSERTER) {\n            emit AsserterTimedOut();\n            _challengerWin();\n        } else if (turn == Turn.CHALLENGER) {\n            emit ChallengerTimedOut();\n            _asserterWin();\n        } else {\n            revert(NO_TURN);\n        }\n    }\n\n    function clearChallenge() external override {\n        require(msg.sender == address(resultReceiver), \"NOT_RES_RECEIVER\");\n        safeSelfDestruct(payable(0));\n    }\n\n    function _currentWin() private {\n        // As a safety measure, challenges can only be resolved by timeouts during mainnet beta.\n        // As state is 0, no move is possible. The other party will lose via timeout\n        challengeStateHash = bytes32(0);\n\n        // if (turn == Turn.ASSERTER) {\n        //     _asserterWin();\n        // } else if (turn == Turn.CHALLENGER) {\n        //     _challengerWin();\n        // } else {\n        // \t   revert(NO_TURN);\n        // }\n    }\n\n    function _asserterWin() private {\n        resultReceiver.completeChallenge(asserter, challenger);\n        safeSelfDestruct(payable(0));\n    }\n\n    function _challengerWin() private {\n        resultReceiver.completeChallenge(challenger, asserter);\n        safeSelfDestruct(payable(0));\n    }\n}\n"
    },
    "src/osp/IOneStepProofEntry.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./IOneStepProver.sol\";\n\ninterface IOneStepProofEntry {\n    function proveOneStep(\n        ExecutionContext calldata execCtx,\n        uint256 machineStep,\n        bytes32 beforeHash,\n        bytes calldata proof\n    ) external view returns (bytes32 afterHash);\n}\n"
    },
    "src/rollup/IChallengeResultReceiver.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ninterface IChallengeResultReceiver {\n\tfunction completeChallenge(address winner, address loser) external;\n}\n"
    },
    "src/rollup/ChallengeLib.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"../state/Machines.sol\";\n\nlibrary ChallengeLib {\n    function hashChallengeState(\n        uint256 segmentsStart,\n        uint256 segmentsLength,\n        bytes32[] memory segments\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(segmentsStart, segmentsLength, segments)\n            );\n    }\n\n    function extractChallengeSegment(\n        bytes32 challengeStateHash,\n        uint256 oldSegmentsStart,\n        uint256 oldSegmentsLength,\n        bytes32[] calldata oldSegments,\n        uint256 challengePosition\n    ) internal pure returns (uint256 segmentStart, uint256 segmentLength) {\n        require(\n            challengeStateHash ==\n                ChallengeLib.hashChallengeState(\n                    oldSegmentsStart,\n                    oldSegmentsLength,\n                    oldSegments\n                ),\n            \"BIS_STATE\"\n        );\n        if (\n            oldSegments.length < 2 ||\n            challengePosition >= oldSegments.length - 1\n        ) {\n            revert(\"BAD_CHALLENGE_POS\");\n        }\n        uint256 oldChallengeDegree = oldSegments.length - 1;\n        segmentLength = oldSegmentsLength / oldChallengeDegree;\n        // Intentionally done before challengeLength is potentially added to for the final segment\n        segmentStart = oldSegmentsStart + segmentLength * challengePosition;\n        if (challengePosition == oldSegments.length - 2) {\n            segmentLength += oldSegmentsLength % oldChallengeDegree;\n        }\n    }\n\n    function blockStateHash(MachineStatus status, bytes32 globalStateHash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        if (status == MachineStatus.FINISHED) {\n            return keccak256(abi.encodePacked(\"Block state:\", globalStateHash));\n        } else if (status == MachineStatus.ERRORED) {\n            return\n                keccak256(\n                    abi.encodePacked(\"Block state, errored:\", globalStateHash)\n                );\n        } else if (status == MachineStatus.TOO_FAR) {\n            return keccak256(abi.encodePacked(\"Block state, too far:\"));\n        } else {\n            revert(\"BAD_BLOCK_STATUS\");\n        }\n    }\n}\n"
    },
    "src/rollup/IExecutionChallenge.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ninterface IExecutionChallenge {\n    function clearChallenge() external;\n}\n"
    },
    "src/rollup/Cloneable.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nabstract contract Cloneable {\n\tbool private isMasterCopy;\n\n\tconstructor() {\n\t\tisMasterCopy = true;\n\t}\n\n    function safeSelfDestruct(address payable dest) internal {\n        require(!isMasterCopy, \"NOT_CLONE\");\n        selfdestruct(dest);\n    }\n}\n"
    },
    "src/rollup/BlockChallenge.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"../osp/IOneStepProofEntry.sol\";\nimport \"./IChallengeResultReceiver.sol\";\nimport \"./ChallengeLib.sol\";\nimport \"./IExecutionChallenge.sol\";\nimport \"./IExecutionChallengeFactory.sol\";\nimport \"./Cloneable.sol\";\n\ncontract BlockChallenge is IChallengeResultReceiver, Cloneable {\n    enum Turn {\n        NO_CHALLENGE,\n        ASSERTER,\n        CHALLENGER\n    }\n\n    event InitiatedChallenge();\n    event Bisected(\n        bytes32 indexed challengeRoot,\n        uint256 challengedSegmentStart,\n        uint256 challengedSegmentLength,\n        bytes32[] chainHashes\n    );\n    event AsserterTimedOut();\n    event ChallengerTimedOut();\n    event ContinuedExecutionProven();\n\n    uint256 constant MAX_CHALLENGE_DEGREE = 40;\n\n    string constant NO_TURN = \"NO_TURN\";\n\n    IExecutionChallengeFactory public executionChallengeFactory;\n    IChallengeResultReceiver resultReceiver;\n\n    ExecutionContext public execCtx;\n    bytes32 public wasmModuleRoot;\n\n    bytes32 public challengeStateHash;\n\n    address public asserter;\n    address public challenger;\n\n    uint256 public asserterTimeLeft;\n    uint256 public challengerTimeLeft;\n    uint256 public lastMoveTimestamp;\n\n    Turn public turn;\n\n    IExecutionChallenge public executionChallenge;\n\n    constructor(\n        IExecutionChallengeFactory executionChallengeFactory_,\n        IChallengeResultReceiver resultReceiver_,\n        ExecutionContext memory execCtx_,\n        bytes32 wasmModuleRoot_,\n        bytes32 challengeStateHash_,\n        address asserter_,\n        address challenger_,\n        uint256 asserterTimeLeft_,\n        uint256 challengerTimeLeft_\n    ) {\n        executionChallengeFactory = executionChallengeFactory_;\n        resultReceiver = resultReceiver_;\n        execCtx = execCtx_;\n        wasmModuleRoot = wasmModuleRoot_;\n        challengeStateHash = challengeStateHash_;\n        asserter = asserter_;\n        challenger = challenger_;\n        asserterTimeLeft = asserterTimeLeft_;\n        challengerTimeLeft = challengerTimeLeft_;\n        lastMoveTimestamp = block.timestamp;\n        turn = Turn.CHALLENGER;\n\n        emit InitiatedChallenge();\n    }\n\n    modifier takeTurn() {\n        require(msg.sender == currentResponder(), \"BIS_SENDER\");\n        require(\n            block.timestamp - lastMoveTimestamp <= currentResponderTimeLeft(),\n            \"BIS_DEADLINE\"\n        );\n        require(address(executionChallenge) == address(0), \"BIS_EXEC\");\n\n        _;\n\n        if (turn == Turn.CHALLENGER) {\n            challengerTimeLeft -= block.timestamp - lastMoveTimestamp;\n            turn = Turn.ASSERTER;\n        } else {\n            asserterTimeLeft -= block.timestamp - lastMoveTimestamp;\n            turn = Turn.CHALLENGER;\n        }\n        lastMoveTimestamp = block.timestamp;\n    }\n\n    function currentResponder() public view returns (address) {\n        if (turn == Turn.ASSERTER) {\n            return asserter;\n        } else if (turn == Turn.CHALLENGER) {\n            return challenger;\n        } else {\n            revert(NO_TURN);\n        }\n    }\n\n    function currentResponderTimeLeft() public view returns (uint256) {\n        if (turn == Turn.ASSERTER) {\n            return asserterTimeLeft;\n        } else if (turn == Turn.CHALLENGER) {\n            return challengerTimeLeft;\n        } else {\n            revert(NO_TURN);\n        }\n    }\n\n    /**\n     * @notice Initiate the next round in the bisection by objecting to execution correctness with a bisection\n     * of an execution segment with the same length but a different endpoint. This is either the initial move\n     * or follows another execution objection\n     */\n    function bisectExecution(\n        uint256 oldSegmentsStart,\n        uint256 oldSegmentsLength,\n        bytes32[] calldata oldSegments,\n        uint256 challengePosition,\n        bytes32[] calldata newSegments\n    ) external takeTurn {\n        (uint256 challengeStart, uint256 challengeLength) = ChallengeLib\n            .extractChallengeSegment(\n                challengeStateHash,\n                oldSegmentsStart,\n                oldSegmentsLength,\n                oldSegments,\n                challengePosition\n            );\n        {\n            uint256 expectedDegree = challengeLength;\n            if (expectedDegree > MAX_CHALLENGE_DEGREE) {\n                expectedDegree = MAX_CHALLENGE_DEGREE;\n            }\n            require(expectedDegree >= 1, \"BAD_DEGREE\");\n            require(newSegments.length == expectedDegree + 1, \"WRONG_DEGREE\");\n        }\n        require(\n            newSegments[newSegments.length - 1] !=\n                oldSegments[challengePosition + 1],\n            \"SAME_END\"\n        );\n\n        require(oldSegments[challengePosition] == newSegments[0], \"DIFF_START\");\n\n        challengeStateHash = ChallengeLib.hashChallengeState(\n            challengeStart,\n            challengeLength,\n            newSegments\n        );\n\n        emit Bisected(\n            challengeStateHash,\n            challengeStart,\n            challengeLength,\n            newSegments\n        );\n    }\n\n    function challengeExecution(\n        uint256 oldSegmentsStart,\n        uint256 oldSegmentsLength,\n        bytes32[] calldata oldSegments,\n        uint256 challengePosition,\n        MachineStatus[2] calldata machineStatuses,\n        bytes32[2] calldata globalStateHashes\n    ) external {\n        require(msg.sender == currentResponder(), \"EXEC_SENDER\");\n        require(\n            block.timestamp - lastMoveTimestamp <= currentResponderTimeLeft(),\n            \"EXEC_DEADLINE\"\n        );\n\n        (, uint256 challengeLength) = ChallengeLib.extractChallengeSegment(\n            challengeStateHash,\n            oldSegmentsStart,\n            oldSegmentsLength,\n            oldSegments,\n            challengePosition\n        );\n        require(challengeLength == 1, \"TOO_LONG\");\n\n        address newAsserter = asserter;\n        address newChallenger = challenger;\n        uint256 newAsserterTimeLeft = asserterTimeLeft;\n        uint256 newChallengerTimeLeft = challengerTimeLeft;\n\n        if (turn == Turn.CHALLENGER) {\n            (newAsserter, newChallenger) = (newChallenger, newAsserter);\n            (newAsserterTimeLeft, newChallengerTimeLeft) = (\n                newChallengerTimeLeft,\n                newAsserterTimeLeft\n            );\n        } else if (turn != Turn.ASSERTER) {\n            revert(NO_TURN);\n        }\n\n        require(\n            oldSegments[challengePosition] ==\n                ChallengeLib.blockStateHash(\n                    machineStatuses[0],\n                    globalStateHashes[0]\n                ),\n            \"WRONG_START\"\n        );\n        require(\n            oldSegments[challengePosition + 1] !=\n                ChallengeLib.blockStateHash(\n                    machineStatuses[1],\n                    globalStateHashes[1]\n                ),\n            \"SAME_END\"\n        );\n\n        if (machineStatuses[0] != MachineStatus.FINISHED) {\n            // If the machine is in a halted state, it can't change\n            require(\n                machineStatuses[0] == machineStatuses[1] &&\n                    globalStateHashes[0] == globalStateHashes[1],\n                \"HALTED_CHANGE\"\n            );\n            _currentWin();\n            return;\n        }\n\n        if (machineStatuses[1] == MachineStatus.ERRORED) {\n            // If the machine errors, it must return to the previous global state\n            require(globalStateHashes[0] == globalStateHashes[1], \"ERROR_CHANGE\");\n        }\n\n        bytes32 execChallengeStateHash;\n        {\n            bytes32 startMachineHash = getStartMachineHash(\n                globalStateHashes[0]\n            );\n            bytes32 endMachineHash = getEndMachineHash(\n                machineStatuses[1],\n                globalStateHashes[1]\n            );\n            bytes32[] memory machineSegments = new bytes32[](2);\n            machineSegments[0] = startMachineHash;\n            machineSegments[1] = endMachineHash;\n            execChallengeStateHash = ChallengeLib.hashChallengeState(\n                0,\n                ~uint64(0), // Constrain max machine steps to max uint64\n                machineSegments\n            );\n        }\n\n        executionChallenge = executionChallengeFactory.createChallenge(\n            this,\n            execCtx,\n            execChallengeStateHash,\n            newAsserter,\n            newChallenger,\n            newAsserterTimeLeft,\n            newChallengerTimeLeft\n        );\n        turn = Turn.NO_CHALLENGE;\n    }\n\n    function getStartMachineHash(bytes32 globalStateHash)\n        internal\n        view\n        returns (bytes32)\n    {\n        ValueStack memory values;\n        {\n            // Start the value stack with the function call ABI for the entrypoint\n            Value[] memory startingValues = new Value[](3);\n            startingValues[0] = Values.newRefNull();\n            startingValues[1] = Values.newI32(0);\n            startingValues[2] = Values.newI32(0);\n            ValueArray memory valuesArray = ValueArray({\n                inner: startingValues\n            });\n            values = ValueStack({\n                proved: valuesArray,\n                remainingHash: 0\n            });\n        }\n\t\tValueStack memory internalStack;\n\t\tPcStack memory blocks;\n\t\tStackFrameWindow memory frameStack;\n\n\t\tMachine memory mach = Machine({\n\t\t\tstatus: MachineStatus.RUNNING,\n\t\t\tvalueStack: values,\n\t\t\tinternalStack: internalStack,\n\t\t\tblockStack: blocks,\n\t\t\tframeStack: frameStack,\n\t\t\tglobalStateHash: globalStateHash,\n\t\t\tmoduleIdx: 0,\n\t\t\tfunctionIdx: 0,\n\t\t\tfunctionPc: 0,\n\t\t\tmodulesRoot: wasmModuleRoot\n\t\t});\n        return Machines.hash(mach);\n    }\n\n    function getEndMachineHash(MachineStatus status, bytes32 globalStateHash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        if (status == MachineStatus.FINISHED) {\n            return\n                keccak256(\n                    abi.encodePacked(\"Machine finished:\", globalStateHash)\n                );\n        } else if (status == MachineStatus.ERRORED) {\n            return keccak256(abi.encodePacked(\"Machine errored:\"));\n        } else if (status == MachineStatus.TOO_FAR) {\n            return keccak256(abi.encodePacked(\"Machine too far:\"));\n        } else {\n            revert(\"BAD_BLOCK_STATUS\");\n        }\n    }\n\n    function timeout() external {\n        require(address(executionChallenge) != address(0), \"TIMEOUT_EXEC\");\n        uint256 timeSinceLastMove = block.timestamp - lastMoveTimestamp;\n        require(\n            timeSinceLastMove > currentResponderTimeLeft(),\n            \"TIMEOUT_DEADLINE\"\n        );\n\n        if (turn == Turn.ASSERTER) {\n            emit AsserterTimedOut();\n            _challengerWin();\n        } else if (turn == Turn.CHALLENGER) {\n            emit ChallengerTimedOut();\n            _asserterWin();\n        } else {\n            revert(NO_TURN);\n        }\n    }\n\n    function clearChallenge() external {\n        require(msg.sender == address(resultReceiver), \"NOT_RES_RECEIVER\");\n        if (address(executionChallenge) != address(0)) {\n            executionChallenge.clearChallenge();\n        }\n        safeSelfDestruct(payable(0));\n    }\n\n    function completeChallenge(address winner, address loser)\n        external\n        override\n    {\n        require(msg.sender == address(executionChallenge), \"NOT_EXEC_CHAL\");\n        resultReceiver.completeChallenge(winner, loser);\n        safeSelfDestruct(payable(0));\n    }\n\n    function _currentWin() private {\n        // As a safety measure, challenges can only be resolved by timeouts during mainnet beta.\n        // As state is 0, no move is possible. The other party will lose via timeout\n        challengeStateHash = bytes32(0);\n\n        // if (turn == Turn.ASSERTER) {\n        //     _asserterWin();\n        // } else if (turn == Turn.CHALLENGER) {\n        //     _challengerWin();\n        // } else {\n        // \t   revert(NO_TURN);\n        // }\n    }\n\n    function _asserterWin() private {\n        resultReceiver.completeChallenge(asserter, challenger);\n        safeSelfDestruct(payable(0));\n    }\n\n    function _challengerWin() private {\n        resultReceiver.completeChallenge(challenger, asserter);\n        safeSelfDestruct(payable(0));\n    }\n}\n"
    },
    "src/rollup/IExecutionChallengeFactory.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"../osp/IOneStepProofEntry.sol\";\nimport \"./IExecutionChallenge.sol\";\nimport \"./IChallengeResultReceiver.sol\";\n\ninterface IExecutionChallengeFactory {\n    function createChallenge(\n        IChallengeResultReceiver resultReceiver_,\n        ExecutionContext memory execCtx_,\n        bytes32 challengeStateHash_,\n        address asserter_,\n        address challenger_,\n        uint256 asserterTimeLeft_,\n        uint256 challengerTimeLeft_\n    ) external returns (IExecutionChallenge);\n}\n"
    },
    "src/osp/OneStepProofEntry.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"../state/Deserialize.sol\";\nimport \"../state/Machines.sol\";\nimport \"../state/MerkleProofs.sol\";\nimport \"./IOneStepProver.sol\";\nimport \"./IOneStepProofEntry.sol\";\n\ncontract OneStepProofEntry is IOneStepProofEntry {\n    IOneStepProver prover0;\n    IOneStepProver proverMem;\n    IOneStepProver proverMath;\n    IOneStepProver proverHostIo;\n\n    uint256 constant MAX_STEPS = 1 << 43;\n\n    constructor(\n        IOneStepProver prover0_,\n        IOneStepProver proverMem_,\n        IOneStepProver proverMath_,\n        IOneStepProver proverHostIo_\n    ) {\n        prover0 = prover0_;\n        proverMem = proverMem_;\n        proverMath = proverMath_;\n        proverHostIo = proverHostIo_;\n    }\n\n    function proveOneStep(\n        ExecutionContext calldata execCtx,\n        uint256 machineStep,\n        bytes32 beforeHash,\n        bytes calldata proof\n    ) external view override returns (bytes32 afterHash) {\n        Machine memory mach;\n        Module memory mod;\n        MerkleProof memory modProof;\n        Instruction memory inst;\n\n        {\n            uint256 offset = 0;\n            (mach, offset) = Deserialize.machine(proof, offset);\n            require(Machines.hash(mach) == beforeHash, \"MACHINE_BEFORE_HASH\");\n            if (mach.status != MachineStatus.RUNNING) {\n                // Machine is halted.\n                // WARNING: at this point, most machine fields are unconstrained.\n                return Machines.hash(mach);\n            }\n\n            if (machineStep + 1 == MAX_STEPS) {\n                mach.status = MachineStatus.ERRORED;\n                return Machines.hash(mach);\n            }\n\n            (mod, offset) = Deserialize.module(proof, offset);\n            (modProof, offset) = Deserialize.merkleProof(proof, offset);\n            require(\n                MerkleProofs.computeRootFromModule(modProof, mach.moduleIdx, mod) ==\n                    mach.modulesRoot,\n                \"MODULES_ROOT\"\n            );\n\n            {\n                MerkleProof memory instProof;\n                MerkleProof memory funcProof;\n                (inst, offset) = Deserialize.instruction(proof, offset);\n                (instProof, offset) = Deserialize.merkleProof(proof, offset);\n                (funcProof, offset) = Deserialize.merkleProof(proof, offset);\n                bytes32 codeHash = MerkleProofs.computeRootFromInstruction(\n                    instProof,\n                    mach.functionPc,\n                    inst\n                );\n                bytes32 recomputedRoot = MerkleProofs.computeRootFromFunction(\n                    funcProof,\n                    mach.functionIdx,\n                    codeHash\n                );\n                require(\n                    recomputedRoot == mod.functionsMerkleRoot,\n                    \"BAD_FUNCTIONS_ROOT\"\n                );\n            }\n            proof = proof[offset:];\n        }\n\n        uint256 oldModIdx = mach.moduleIdx;\n        mach.functionPc += 1;\n        uint16 opcode = inst.opcode;\n        IOneStepProver prover;\n        if (\n            (opcode >= Instructions.I32_LOAD &&\n                opcode <= Instructions.I64_LOAD32_U) ||\n            (opcode >= Instructions.I32_STORE &&\n                opcode <= Instructions.I64_STORE32) ||\n            opcode == Instructions.MEMORY_SIZE ||\n            opcode == Instructions.MEMORY_GROW\n        ) {\n            prover = proverMem;\n        } else if (\n            (opcode == Instructions.I32_EQZ ||\n                opcode == Instructions.I64_EQZ) ||\n            (opcode >= Instructions.I32_RELOP_BASE &&\n                opcode <=\n                Instructions.I32_RELOP_BASE + Instructions.IRELOP_LAST) ||\n            (opcode >= Instructions.I32_UNOP_BASE &&\n                opcode <=\n                Instructions.I32_UNOP_BASE + Instructions.IUNOP_LAST) ||\n            (opcode >= Instructions.I32_ADD &&\n                opcode <= Instructions.I32_ROTR) ||\n            (opcode >= Instructions.I64_RELOP_BASE &&\n                opcode <=\n                Instructions.I64_RELOP_BASE + Instructions.IRELOP_LAST) ||\n            (opcode >= Instructions.I64_UNOP_BASE &&\n                opcode <=\n                Instructions.I64_UNOP_BASE + Instructions.IUNOP_LAST) ||\n            (opcode >= Instructions.I64_ADD &&\n                opcode <= Instructions.I64_ROTR) ||\n            (opcode == Instructions.I32_WRAP_I64) ||\n            (opcode == Instructions.I64_EXTEND_I32_S ||\n                opcode == Instructions.I64_EXTEND_I32_U) ||\n            (opcode >= Instructions.I32_EXTEND_8S &&\n                opcode <= Instructions.I64_EXTEND_32S) ||\n            (opcode >= Instructions.I32_REINTERPRET_F32 &&\n                opcode <= Instructions.F64_REINTERPRET_I64)\n        ) {\n            prover = proverMath;\n        } else if (\n            (opcode >= Instructions.GET_GLOBAL_STATE_BYTES32 &&\n                opcode <= Instructions.SET_GLOBAL_STATE_U64) ||\n            (opcode >= Instructions.READ_PRE_IMAGE &&\n                opcode <= Instructions.HALT_AND_SET_FINISHED)\n        ) {\n            prover = proverHostIo;\n        } else {\n            prover = prover0;\n        }\n\n        (mach, mod) = prover.executeOneStep(\n            execCtx,\n            mach,\n            mod,\n            inst,\n            proof\n        );\n\n        mach.modulesRoot = MerkleProofs.computeRootFromModule(\n            modProof,\n            oldModIdx,\n            mod\n        );\n\n        return Machines.hash(mach);\n    }\n}\n"
    },
    "src/osp/OneStepProverMemory.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"../state/Values.sol\";\nimport \"../state/Machines.sol\";\nimport \"../state/Deserialize.sol\";\nimport \"./IOneStepProver.sol\";\n\ncontract OneStepProverMemory is IOneStepProver {\n    uint256 constant LEAF_SIZE = 32;\n    uint64 constant PAGE_SIZE = 65536;\n\n    function pullLeafByte(bytes32 leaf, uint256 idx)\n        internal\n        pure\n        returns (uint8)\n    {\n        require(idx < LEAF_SIZE, \"BAD_PULL_LEAF_BYTE_IDX\");\n        // Take into account that we are casting the leaf to a big-endian integer\n        uint256 leafShift = (LEAF_SIZE - 1 - idx) * 8;\n        return uint8(uint256(leaf) >> leafShift);\n    }\n\n    function setLeafByte(\n        bytes32 oldLeaf,\n        uint256 idx,\n        uint8 val\n    ) internal pure returns (bytes32) {\n        require(idx < LEAF_SIZE, \"BAD_SET_LEAF_BYTE_IDX\");\n        // Take into account that we are casting the leaf to a big-endian integer\n        uint256 leafShift = (LEAF_SIZE - 1 - idx) * 8;\n        uint256 newLeaf = uint256(oldLeaf);\n        newLeaf &= ~(0xFF << leafShift);\n        newLeaf |= uint256(val) << leafShift;\n        return bytes32(newLeaf);\n    }\n\n    function executeMemoryLoad(\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal pure {\n        ValueType ty;\n        uint256 readBytes;\n        bool signed;\n        if (inst.opcode == Instructions.I32_LOAD) {\n            ty = ValueType.I32;\n            readBytes = 4;\n            signed = false;\n        } else if (inst.opcode == Instructions.I64_LOAD) {\n            ty = ValueType.I64;\n            readBytes = 8;\n            signed = false;\n        } else if (inst.opcode == Instructions.F32_LOAD) {\n            ty = ValueType.F32;\n            readBytes = 4;\n            signed = false;\n        } else if (inst.opcode == Instructions.F64_LOAD) {\n            ty = ValueType.F64;\n            readBytes = 8;\n            signed = false;\n        } else if (inst.opcode == Instructions.I32_LOAD8_S) {\n            ty = ValueType.I32;\n            readBytes = 1;\n            signed = true;\n        } else if (inst.opcode == Instructions.I32_LOAD8_U) {\n            ty = ValueType.I32;\n            readBytes = 1;\n            signed = false;\n        } else if (inst.opcode == Instructions.I32_LOAD16_S) {\n            ty = ValueType.I32;\n            readBytes = 2;\n            signed = true;\n        } else if (inst.opcode == Instructions.I32_LOAD16_U) {\n            ty = ValueType.I32;\n            readBytes = 2;\n            signed = false;\n        } else if (inst.opcode == Instructions.I64_LOAD8_S) {\n            ty = ValueType.I64;\n            readBytes = 1;\n            signed = true;\n        } else if (inst.opcode == Instructions.I64_LOAD8_U) {\n            ty = ValueType.I64;\n            readBytes = 1;\n            signed = false;\n        } else if (inst.opcode == Instructions.I64_LOAD16_S) {\n            ty = ValueType.I64;\n            readBytes = 2;\n            signed = true;\n        } else if (inst.opcode == Instructions.I64_LOAD16_U) {\n            ty = ValueType.I64;\n            readBytes = 2;\n            signed = false;\n        } else if (inst.opcode == Instructions.I64_LOAD32_S) {\n            ty = ValueType.I64;\n            readBytes = 4;\n            signed = true;\n        } else if (inst.opcode == Instructions.I64_LOAD32_U) {\n            ty = ValueType.I64;\n            readBytes = 4;\n            signed = false;\n        } else {\n            revert(\"INVALID_MEMORY_LOAD_OPCODE\");\n        }\n\n        // Neither of these can overflow as they're computed with much less than 256 bit integers.\n        uint256 startIdx = inst.argumentData +\n            ValueStacks.pop(mach.valueStack).contents;\n        if (startIdx + readBytes > mod.moduleMemory.size) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n\n        uint256 proofOffset = 0;\n        uint256 lastProvedLeafIdx = ~uint256(0);\n        bytes32 lastProvedLeafContents;\n        uint64 readValue;\n        for (uint256 i = 0; i < readBytes; i++) {\n            uint256 idx = startIdx + i;\n            uint256 leafIdx = idx / LEAF_SIZE;\n            if (leafIdx != lastProvedLeafIdx) {\n                (lastProvedLeafContents, proofOffset, ) = ModuleMemories\n                    .proveLeaf(mod.moduleMemory, leafIdx, proof, proofOffset);\n                lastProvedLeafIdx = leafIdx;\n            }\n            uint256 indexWithinLeaf = idx % LEAF_SIZE;\n            readValue |=\n                uint64(pullLeafByte(lastProvedLeafContents, indexWithinLeaf)) <<\n                uint64(i * 8);\n        }\n\n        if (signed) {\n            // Go down to the original uint size, change to signed, go up to correct size, convert back to unsigned\n            if (readBytes == 1 && ty == ValueType.I32) {\n                readValue = uint32(int32(int8(uint8(readValue))));\n            } else if (readBytes == 1 && ty == ValueType.I64) {\n                readValue = uint64(int64(int8(uint8(readValue))));\n            } else if (readBytes == 2 && ty == ValueType.I32) {\n                readValue = uint32(int32(int16(uint16(readValue))));\n            } else if (readBytes == 2 && ty == ValueType.I64) {\n                readValue = uint64(int64(int16(uint16(readValue))));\n            } else if (readBytes == 4 && ty == ValueType.I64) {\n                readValue = uint64(int64(int32(uint32(readValue))));\n            } else {\n                revert(\"BAD_READ_BYTES_SIGNED\");\n            }\n        }\n\n        ValueStacks.push(\n            mach.valueStack,\n            Value({valueType: ty, contents: readValue})\n        );\n    }\n\n    function executeMemoryStore(\n        Machine memory mach,\n        Module memory mod,\n        Instruction calldata inst,\n        bytes calldata proof\n    ) internal pure {\n        uint64 writeBytes;\n        uint64 toWrite;\n        {\n            ValueType ty;\n            if (inst.opcode == Instructions.I32_STORE) {\n                ty = ValueType.I32;\n                writeBytes = 4;\n            } else if (inst.opcode == Instructions.I64_STORE) {\n                ty = ValueType.I64;\n                writeBytes = 8;\n            } else if (inst.opcode == Instructions.F32_STORE) {\n                ty = ValueType.F32;\n                writeBytes = 4;\n            } else if (inst.opcode == Instructions.F64_STORE) {\n                ty = ValueType.F64;\n                writeBytes = 8;\n            } else if (inst.opcode == Instructions.I32_STORE8) {\n                ty = ValueType.I32;\n                writeBytes = 1;\n            } else if (inst.opcode == Instructions.I32_STORE16) {\n                ty = ValueType.I32;\n                writeBytes = 2;\n            } else if (inst.opcode == Instructions.I64_STORE8) {\n                ty = ValueType.I64;\n                writeBytes = 1;\n            } else if (inst.opcode == Instructions.I64_STORE16) {\n                ty = ValueType.I64;\n                writeBytes = 2;\n            } else if (inst.opcode == Instructions.I64_STORE32) {\n                ty = ValueType.I64;\n                writeBytes = 4;\n            } else {\n                revert(\"INVALID_MEMORY_STORE_OPCODE\");\n            }\n\n            Value memory writingVal = ValueStacks.pop(mach.valueStack);\n            require(writingVal.valueType == ty, \"BAD_STORE_TYPE\");\n            toWrite = uint64(writingVal.contents);\n            if (writeBytes < 8) {\n                toWrite &= (uint64(1) << (writeBytes * 8)) - 1;\n            }\n        }\n\n        // Neither of these can overflow as they're computed with much less than 256 bit integers.\n        uint256 startIdx = inst.argumentData +\n            ValueStacks.pop(mach.valueStack).contents;\n        if (startIdx + writeBytes > mod.moduleMemory.size) {\n            mach.status = MachineStatus.ERRORED;\n            return;\n        }\n\n        uint256 proofOffset = 0;\n        uint256 lastProvedLeafIdx = ~uint256(0);\n        MerkleProof memory lastProvedMerkle;\n        bytes32 lastProvedLeafContents;\n        for (uint256 i = 0; i < writeBytes; i++) {\n            uint256 idx = startIdx + i;\n            uint256 leafIdx = idx / LEAF_SIZE;\n            if (leafIdx != lastProvedLeafIdx) {\n                if (lastProvedLeafIdx != ~uint256(0)) {\n                    // Apply the last leaf update\n                    mod.moduleMemory.merkleRoot = MerkleProofs\n                        .computeRootFromMemory(\n                            lastProvedMerkle,\n                            lastProvedLeafIdx,\n                            lastProvedLeafContents\n                        );\n                }\n                (\n                    lastProvedLeafContents,\n                    proofOffset,\n                    lastProvedMerkle\n                ) = ModuleMemories.proveLeaf(\n                    mod.moduleMemory,\n                    leafIdx,\n                    proof,\n                    proofOffset\n                );\n                lastProvedLeafIdx = leafIdx;\n            }\n            uint256 indexWithinLeaf = idx % LEAF_SIZE;\n            lastProvedLeafContents = setLeafByte(\n                lastProvedLeafContents,\n                indexWithinLeaf,\n                uint8(toWrite)\n            );\n            toWrite >>= 8;\n        }\n        mod.moduleMemory.merkleRoot = MerkleProofs.computeRootFromMemory(\n            lastProvedMerkle,\n            lastProvedLeafIdx,\n            lastProvedLeafContents\n        );\n    }\n\n    function executeMemorySize(Machine memory mach, Module memory mod, Instruction calldata, bytes calldata) internal pure {\n        uint32 pages = uint32(mod.moduleMemory.size / PAGE_SIZE);\n        ValueStacks.push(mach.valueStack, Values.newI32(pages));\n    }\n\n    function executeMemoryGrow(Machine memory mach, Module memory mod, Instruction calldata, bytes calldata) internal pure {\n        uint32 oldPages = uint32(mod.moduleMemory.size / PAGE_SIZE);\n        uint32 growingPages = Values.assumeI32(ValueStacks.pop(mach.valueStack));\n        // Safe as the input integers are too small to overflow a uint256\n        uint256 newSize = (uint256(oldPages) + uint256(growingPages)) * PAGE_SIZE;\n        // Note: we require the size remain *below* 2^32, meaning the actual limit is 2^32-PAGE_SIZE\n        if (newSize < (1 << 32)) {\n            mod.moduleMemory.size = uint64(newSize);\n            ValueStacks.push(mach.valueStack, Values.newI32(oldPages));\n        } else {\n            ValueStacks.push(mach.valueStack, Values.newI32(~uint32(0)));\n        }\n    }\n\n    function executeOneStep(ExecutionContext calldata, Machine calldata startMach, Module calldata startMod, Instruction calldata inst, bytes calldata proof)\n        external\n        pure\n        override\n        returns (Machine memory mach, Module memory mod)\n    {\n        mach = startMach;\n        mod = startMod;\n\n        uint16 opcode = inst.opcode;\n\n        function(Machine memory, Module memory, Instruction calldata, bytes calldata)\n            internal\n            pure impl;\n        if (\n            opcode >= Instructions.I32_LOAD &&\n            opcode <= Instructions.I64_LOAD32_U\n        ) {\n            impl = executeMemoryLoad;\n        } else if (\n            opcode >= Instructions.I32_STORE &&\n            opcode <= Instructions.I64_STORE32\n        ) {\n            impl = executeMemoryStore;\n        } else if (opcode == Instructions.MEMORY_SIZE) {\n            impl = executeMemorySize;\n        } else if (opcode == Instructions.MEMORY_GROW) {\n            impl = executeMemoryGrow;\n        } else {\n            revert(\"INVALID_MEMORY_OPCODE\");\n        }\n\n        impl(mach, mod, inst, proof);\n    }\n}\n"
    },
    "src/osp/OneStepProverMath.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"../state/Values.sol\";\nimport \"../state/Machines.sol\";\nimport \"../state/Modules.sol\";\nimport \"../state/Deserialize.sol\";\nimport \"./IOneStepProver.sol\";\n\ncontract OneStepProverMath is IOneStepProver {\n\tfunction executeEqz(Machine memory mach, Module memory, Instruction calldata, bytes calldata) internal pure {\n\t\tValue memory v = ValueStacks.pop(mach.valueStack);\n\n\t\tuint32 output;\n\t\tif (v.contents == 0) {\n\t\t\toutput = 1;\n\t\t} else {\n\t\t\toutput = 0;\n\t\t}\n\n\t\tValueStacks.push(mach.valueStack, Values.newI32(output));\n\t}\n\n\tfunction signExtend(uint32 a) internal pure returns (uint64) {\n\t\tif (a & (1<<31) != 0) {\n\t\t\treturn uint64(a) | uint64(0xffffffff00000000);\n\t\t}\n\t\treturn uint64(a);\n\t}\n\n\tfunction I64RelOp(uint64 a, uint64 b, uint16 relop) internal pure returns (bool) {\n\t\tif (relop == Instructions.IRELOP_EQ) {\n\t\t\treturn (a == b);\n\t\t} else if (relop == Instructions.IRELOP_NE) {\n\t\t\treturn (a != b);\n\t\t} else if (relop == Instructions.IRELOP_LT_S) {\n\t\t\treturn (int64(a) < int64(b));\n\t\t} else if (relop == Instructions.IRELOP_LT_U) {\n\t\t\treturn (a < b);\n\t\t} else if (relop == Instructions.IRELOP_GT_S) {\n\t\t\treturn (int64(a) > int64(b));\n\t\t} else if (relop == Instructions.IRELOP_GT_U) {\n\t\t\treturn (a > b);\n\t\t} else if (relop == Instructions.IRELOP_LE_S) {\n\t\t\treturn (int64(a) <= int64(b));\n\t\t} else if (relop == Instructions.IRELOP_LE_U) {\n\t\t\treturn (a <= b);\n\t\t} else if (relop == Instructions.IRELOP_GE_S) {\n\t\t\treturn (int64(a) >= int64(b));\n\t\t} else if (relop == Instructions.IRELOP_GE_U) {\n\t\t\treturn (a >= b);\n\t\t} else {\n\t\t\trevert (\"BAD IRELOP\");\n\t\t}\n\t}\n\n\tfunction executeI32RelOp(Machine memory mach, Module memory, Instruction calldata inst, bytes calldata) internal pure {\n\t\tuint32 b = Values.assumeI32(ValueStacks.pop(mach.valueStack));\n\t\tuint32 a = Values.assumeI32(ValueStacks.pop(mach.valueStack));\n\n\t\tuint16 relop = inst.opcode - Instructions.I32_RELOP_BASE;\n\t\tuint64 a64;\n\t\tuint64 b64;\n\n\t\tif (relop == Instructions.IRELOP_LT_S || relop == Instructions.IRELOP_GT_S ||\n\t\t\trelop == Instructions.IRELOP_LE_S || relop == Instructions.IRELOP_GE_S) {\n\t\t\ta64 = signExtend(a);\n\t\t\tb64 = signExtend(b);\n\t\t} else {\n\t\t\ta64 = uint64(a);\n\t\t\tb64 = uint64(b);\n\t\t}\n\n\t\tbool res = I64RelOp(a64, b64, relop);\n\n\t\tValueStacks.push(mach.valueStack, Values.newBoolean(res));\n\t}\n\n\tfunction executeI64RelOp(Machine memory mach, Module memory, Instruction calldata inst, bytes calldata) internal pure {\n\t\tuint64 b = Values.assumeI64(ValueStacks.pop(mach.valueStack));\n\t\tuint64 a = Values.assumeI64(ValueStacks.pop(mach.valueStack));\n\n\t\tuint16 relop = inst.opcode - Instructions.I64_RELOP_BASE;\n\n\t\tbool res = I64RelOp(a, b, relop);\n\n\t\tValueStacks.push(mach.valueStack, Values.newBoolean(res));\n\t}\n\n\n\tfunction genericIUnOp(uint64 a, uint16 unop, uint16 bits) internal pure returns (uint32) {\n\t\trequire(bits == 32 || bits == 64, \"WRONG USE OF genericUnOp\");\n\t\tif (unop == Instructions.IUNOP_CLZ) {\n\t\t\t/* curbits is one-based to keep with unsigned mathematics */\n\t\t\tuint32 curbit = bits;\n\t\t\twhile (curbit > 0 && (a & (1 << (curbit - 1)) == 0)) {\n\t\t\t\tcurbit -= 1;\n\t\t\t}\n\t\t\treturn (bits - curbit);\n\t\t} else if (unop == Instructions.IUNOP_CTZ) {\n\t\t\tuint32 curbit = 0;\n\t\t\twhile (curbit < bits && ((a & (1 << curbit)) == 0)) {\n\t\t\t\tcurbit += 1;\n\t\t\t}\n\t\t\treturn curbit;\n\t\t} else if (unop == Instructions.IUNOP_POPCNT) {\n\t\t\tuint32 curbit = 0;\n\t\t\tuint32 res = 0;\n\t\t\twhile (curbit < bits) {\n\t\t\t\tif ((a & (1 << curbit)) != 0) {\n\t\t\t\t\tres += 1;\n\t\t\t\t}\n\t\t\t\tcurbit++;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\trevert(\"BAD IUnOp\");\n\t}\n\n\tfunction executeI32UnOp(Machine memory mach, Module memory, Instruction calldata inst, bytes calldata) internal pure {\n\t\tuint32 a = Values.assumeI32(ValueStacks.pop(mach.valueStack));\n\n\t\tuint16 unop = inst.opcode - Instructions.I32_UNOP_BASE;\n\n\t\tuint32 res = genericIUnOp(a, unop, 32);\n\n\t\tValueStacks.push(mach.valueStack, Values.newI32(res));\n\t}\n\n\tfunction executeI64UnOp(Machine memory mach, Module memory, Instruction calldata inst, bytes calldata) internal pure {\n\t\tuint64 a = Values.assumeI64(ValueStacks.pop(mach.valueStack));\n\n\t\tuint16 unop = inst.opcode - Instructions.I64_UNOP_BASE;\n\n\t\tuint64 res = uint64(genericIUnOp(a, unop, 64));\n\n\t\tValueStacks.push(mach.valueStack, Values.newI64(res));\n\t}\n\n\tfunction rotl32(uint32 a, uint32 b) internal pure returns (uint32) {\n\t\tb %= 32;\n\t\treturn (a << b) | (a >> (32 - b));\n\t}\n\n\tfunction rotl64(uint64 a, uint64 b) internal pure returns (uint64) {\n\t\tb %= 64;\n\t\treturn (a << b) | (a >> (64 - b));\n\t}\n\n\tfunction rotr32(uint32 a, uint32 b) internal pure returns (uint32) {\n\t\tb %= 32;\n\t\treturn (a >> b) | (a << (32 - b));\n\t}\n\n\tfunction rotr64(uint64 a, uint64 b) internal pure returns (uint64) {\n\t\tb %= 64;\n\t\treturn (a >> b) | (a << (64 - b));\n\t}\n\n\tfunction genericBinOp(uint64 a, uint64 b, uint16 opcodeOffset) internal pure returns (uint64) {\n\t\tunchecked {\n\t\t\tif (opcodeOffset == 0) {\n\t\t\t\t// add\n\t\t\t\treturn a + b;\n\t\t\t} else if (opcodeOffset == 1) {\n\t\t\t\t// sub\n\t\t\t\treturn a - b;\n\t\t\t} else if (opcodeOffset == 2) {\n\t\t\t\t// mul\n\t\t\t\treturn a * b;\n\t\t\t} else if (opcodeOffset == 4) {\n\t\t\t\t// div_u\n\t\t\t\tif (b == 0) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn a / b;\n\t\t\t} else if (opcodeOffset == 6) {\n\t\t\t\t// rem_u\n\t\t\t\tif (b == 0) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn a % b;\n\t\t\t} else if (opcodeOffset == 7) {\n\t\t\t\t// and\n\t\t\t\treturn a & b;\n\t\t\t} else if (opcodeOffset == 8) {\n\t\t\t\t// or\n\t\t\t\treturn a | b;\n\t\t\t} else if (opcodeOffset == 9) {\n\t\t\t\t// xor\n\t\t\t\treturn a ^ b;\n\t\t\t} else {\n\t\t\t\trevert(\"INVALID_GENERIC_BIN_OP\");\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction executeI32BinOp(Machine memory mach, Module memory, Instruction calldata inst, bytes calldata) internal pure {\n\t\tuint32 b = Values.assumeI32(ValueStacks.pop(mach.valueStack));\n\t\tuint32 a = Values.assumeI32(ValueStacks.pop(mach.valueStack));\n\t\tuint32 res;\n\n\t\tuint16 opcodeOffset = inst.opcode - Instructions.I32_ADD;\n\n\t\tunchecked {\n\t\t\tif (opcodeOffset == 3) {\n\t\t\t\t// div_s\n\t\t\t\tif (b == 0) {\n\t\t\t\t\tres = 0;\n\t\t\t\t} else {\n\t\t\t\t\tres = uint32(int32(a) / int32(b));\n\t\t\t\t}\n\t\t\t} else if (opcodeOffset == 5) {\n\t\t\t\t// rem_s\n\t\t\t\tif (b == 0) {\n\t\t\t\t\tres = 0;\n\t\t\t\t} else {\n\t\t\t\t\tres = uint32(int32(a) % int32(b));\n\t\t\t\t}\n\t\t\t} else if (opcodeOffset == 10) {\n\t\t\t\t// shl\n\t\t\t\tres = a << (b % 32);\n\t\t\t} else if (opcodeOffset == 12) {\n\t\t\t\t// shr_u\n\t\t\t\tres = a >> (b % 32);\n\t\t\t} else if (opcodeOffset == 11) {\n\t\t\t\t// shr_s\n\t\t\t\tres = uint32(int32(a) >> b);\n\t\t\t} else if (opcodeOffset == 13) {\n\t\t\t\t// rotl\n\t\t\t\tres = rotl32(a, b);\n\t\t\t} else if (opcodeOffset == 14) {\n\t\t\t\t// rotr\n\t\t\t\tres = rotr32(a, b);\n\t\t\t} else {\n\t\t\t\tres = uint32(genericBinOp(a, b, opcodeOffset));\n\t\t\t}\n\t\t}\n\n\t\tValueStacks.push(mach.valueStack, Values.newI32(res));\n\t}\n\n\tfunction executeI64BinOp(Machine memory mach, Module memory, Instruction calldata inst, bytes calldata) internal pure {\n\t\tuint64 b = Values.assumeI64(ValueStacks.pop(mach.valueStack));\n\t\tuint64 a = Values.assumeI64(ValueStacks.pop(mach.valueStack));\n\t\tuint64 res;\n\n\t\tuint16 opcodeOffset = inst.opcode - Instructions.I64_ADD;\n\n\t\tunchecked {\n\t\t\tif (opcodeOffset == 3) {\n\t\t\t\t// div_s\n\t\t\t\tif (b == 0) {\n\t\t\t\t\tres = 0;\n\t\t\t\t} else {\n\t\t\t\t\tres = uint64(int64(a) / int64(b));\n\t\t\t\t}\n\t\t\t} else if (opcodeOffset == 5) {\n\t\t\t\t// rem_s\n\t\t\t\tif (b == 0) {\n\t\t\t\t\tres = 0;\n\t\t\t\t} else {\n\t\t\t\t\tres = uint64(int64(a) % int64(b));\n\t\t\t\t}\n\t\t\t} else if (opcodeOffset == 10) {\n\t\t\t\t// shl\n\t\t\t\tres = a << (b % 64);\n\t\t\t} else if (opcodeOffset == 12) {\n\t\t\t\t// shr_u\n\t\t\t\tres = a >> (b % 64);\n\t\t\t} else if (opcodeOffset == 11) {\n\t\t\t\t// shr_s\n\t\t\t\tres = uint64(int64(a) >> b);\n\t\t\t} else if (opcodeOffset == 13) {\n\t\t\t\t// rotl\n\t\t\t\tres = rotl64(a, b);\n\t\t\t} else if (opcodeOffset == 14) {\n\t\t\t\t// rotr\n\t\t\t\tres = rotr64(a, b);\n\t\t\t} else {\n\t\t\t\tres = genericBinOp(a, b, opcodeOffset);\n\t\t\t}\n\t\t}\n\n\t\tValueStacks.push(mach.valueStack, Values.newI64(res));\n\t}\n\n\tfunction executeI32WrapI64(Machine memory mach, Module memory, Instruction calldata, bytes calldata) internal pure {\n\t\tuint64 a = Values.assumeI64(ValueStacks.pop(mach.valueStack));\n\n\t\tuint32 a32 = uint32(a);\n\n\t\tValueStacks.push(mach.valueStack, Values.newI32(a32));\n\t}\n\n\tfunction executeI64ExtendI32(Machine memory mach, Module memory, Instruction calldata inst, bytes calldata) internal pure {\n\t\tuint32 a = Values.assumeI32(ValueStacks.pop(mach.valueStack));\n\n\t\tuint64 a64;\n\n\t\tif (inst.opcode == Instructions.I64_EXTEND_I32_S) {\n\t\t\ta64 = signExtend(a);\n\t\t} else {\n\t\t\ta64 = uint64(a);\n\t\t}\n\n\t\tValueStacks.push(mach.valueStack, Values.newI64(a64));\n\t}\n\n\tfunction executeExtendSameType(Machine memory mach, Module memory, Instruction calldata inst, bytes calldata) internal pure {\n\t\tValueType ty;\n\t\tuint8 sourceBits;\n\t\tif (inst.opcode == Instructions.I32_EXTEND_8S) {\n\t\t\tty = ValueType.I32;\n\t\t\tsourceBits = 8;\n\t\t} else if (inst.opcode == Instructions.I32_EXTEND_16S) {\n\t\t\tty = ValueType.I32;\n\t\t\tsourceBits = 16;\n\t\t} else if (inst.opcode == Instructions.I64_EXTEND_8S) {\n\t\t\tty = ValueType.I64;\n\t\t\tsourceBits = 8;\n\t\t} else if (inst.opcode == Instructions.I64_EXTEND_16S) {\n\t\t\tty = ValueType.I64;\n\t\t\tsourceBits = 16;\n\t\t} else if (inst.opcode == Instructions.I64_EXTEND_32S) {\n\t\t\tty = ValueType.I64;\n\t\t\tsourceBits = 32;\n\t\t} else {\n\t\t\trevert(\"INVALID_EXTEND_SAME_TYPE\");\n\t\t}\n\t\tuint256 resultMask;\n\t\tif (ty == ValueType.I32) {\n\t\t\tresultMask = (1 << 32) - 1;\n\t\t} else {\n\t\t\tresultMask = (1 << 64) - 1;\n\t\t}\n\t\tValue memory val = ValueStacks.pop(mach.valueStack);\n\t\trequire(val.valueType == ty, \"BAD_EXTEND_SAME_TYPE_TYPE\");\n\t\tuint256 sourceMask = (1 << sourceBits) - 1;\n\t\tval.contents &= sourceMask;\n\t\tif (val.contents & (1 << (sourceBits - 1)) != 0) {\n\t\t\t// Extend sign flag\n\t\t\tval.contents |= resultMask & ~sourceMask;\n\t\t}\n\t\tValueStacks.push(mach.valueStack, val);\n\t}\n\n\tfunction executeReinterpret(Machine memory mach, Module memory, Instruction calldata inst, bytes calldata) internal pure {\n\t\tValueType destTy;\n\t\tValueType sourceTy;\n\t\tif (inst.opcode == Instructions.I32_REINTERPRET_F32) {\n\t\t\tdestTy = ValueType.I32;\n\t\t\tsourceTy = ValueType.F32;\n\t\t} else if (inst.opcode == Instructions.I64_REINTERPRET_F64) {\n\t\t\tdestTy = ValueType.I64;\n\t\t\tsourceTy = ValueType.F64;\n\t\t} else if (inst.opcode == Instructions.F32_REINTERPRET_I32) {\n\t\t\tdestTy = ValueType.F32;\n\t\t\tsourceTy = ValueType.I32;\n\t\t} else if (inst.opcode == Instructions.F64_REINTERPRET_I64) {\n\t\t\tdestTy = ValueType.F64;\n\t\t\tsourceTy = ValueType.I64;\n\t\t} else {\n\t\t\trevert(\"INVALID_REINTERPRET\");\n\t\t}\n\t\tValue memory val = ValueStacks.pop(mach.valueStack);\n\t\trequire(val.valueType == sourceTy, \"INVALID_REINTERPRET_TYPE\");\n\t\tval.valueType = destTy;\n\t\tValueStacks.push(mach.valueStack, val);\n\t}\n\n\tfunction executeOneStep(ExecutionContext calldata, Machine calldata startMach, Module calldata startMod, Instruction calldata inst, bytes calldata proof) override pure external returns (Machine memory mach, Module memory mod) {\n\t\tmach = startMach;\n\t\tmod = startMod;\n\n\t\tuint16 opcode = inst.opcode;\n\n\t\tfunction(Machine memory, Module memory, Instruction calldata, bytes calldata) internal pure impl;\n\t\tif (opcode == Instructions.I32_EQZ || opcode == Instructions.I64_EQZ) {\n\t\t\timpl = executeEqz;\n\t\t} else if (opcode >= Instructions.I32_RELOP_BASE && opcode <= Instructions.I32_RELOP_BASE + Instructions.IRELOP_LAST) {\n\t\t\timpl = executeI32RelOp;\n\t\t} else if (opcode >= Instructions.I32_UNOP_BASE && opcode <= Instructions.I32_UNOP_BASE + Instructions.IUNOP_LAST) {\n\t\t\timpl = executeI32UnOp;\n\t\t} else if (opcode >= Instructions.I32_ADD && opcode <= Instructions.I32_ROTR) {\n\t\t\timpl = executeI32BinOp;\n\t\t} else if (opcode >= Instructions.I64_RELOP_BASE && opcode <= Instructions.I64_RELOP_BASE + Instructions.IRELOP_LAST) {\n\t\t\timpl = executeI64RelOp;\n\t\t} else if (opcode >= Instructions.I64_UNOP_BASE && opcode <= Instructions.I64_UNOP_BASE + Instructions.IUNOP_LAST) {\n\t\t\timpl = executeI64UnOp;\n\t\t} else if (opcode >= Instructions.I64_ADD && opcode <= Instructions.I64_ROTR) {\n\t\t\timpl = executeI64BinOp;\n\t\t} else if (opcode == Instructions.I32_WRAP_I64) {\n\t\t\timpl = executeI32WrapI64;\n\t\t} else if (opcode == Instructions.I64_EXTEND_I32_S || opcode == Instructions.I64_EXTEND_I32_U) {\n\t\t\timpl = executeI64ExtendI32;\n\t\t} else if (opcode >= Instructions.I32_EXTEND_8S && opcode <= Instructions.I64_EXTEND_32S) {\n\t\t\timpl = executeExtendSameType;\n\t\t} else if (opcode >= Instructions.I32_REINTERPRET_F32 && opcode <= Instructions.F64_REINTERPRET_I64) {\n\t\t\timpl = executeReinterpret;\n\t\t} else {\n\t\t\trevert(\"INVALID_OPCODE\");\n\t\t}\n\n\t\timpl(mach, mod, inst, proof);\n\t}\n}\n\n"
    },
    "src/osp/OneStepProver0.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"../state/Values.sol\";\nimport \"../state/Machines.sol\";\nimport \"../state/Modules.sol\";\nimport \"../state/Deserialize.sol\";\nimport \"./IOneStepProver.sol\";\n\ncontract OneStepProver0 is IOneStepProver {\n\tfunction executeUnreachable(Machine memory mach, Module memory, Instruction calldata, bytes calldata) internal pure {\n\t\tmach.status = MachineStatus.ERRORED;\n\t}\n\n\tfunction executeNop(Machine memory mach, Module memory, Instruction calldata, bytes calldata) internal pure {\n\t\t// :)\n\t}\n\n\tfunction executeConstPush(Machine memory mach, Module memory, Instruction calldata inst, bytes calldata) internal pure {\n\t\tuint16 opcode = inst.opcode;\n\t\tValueType ty;\n\t\tif (opcode == Instructions.I32_CONST) {\n\t\t\tty = ValueType.I32;\n\t\t} else if (opcode == Instructions.I64_CONST) {\n\t\t\tty = ValueType.I64;\n\t\t} else if (opcode == Instructions.F32_CONST) {\n\t\t\tty = ValueType.F32;\n\t\t} else if (opcode == Instructions.F64_CONST) {\n\t\t\tty = ValueType.F64;\n\t\t} else if (opcode == Instructions.PUSH_STACK_BOUNDARY) {\n\t\t\tty = ValueType.STACK_BOUNDARY;\n\t\t} else {\n\t\t\trevert(\"CONST_PUSH_INVALID_OPCODE\");\n\t\t}\n\n\t\tValueStacks.push(mach.valueStack, Value({\n\t\t\tvalueType: ty,\n\t\t\tcontents: uint64(inst.argumentData)\n\t\t}));\n\t}\n\n\tfunction executeDrop(Machine memory mach, Module memory, Instruction calldata, bytes calldata) internal pure {\n\t\tValueStacks.pop(mach.valueStack);\n\t}\n\n\tfunction executeSelect(Machine memory mach, Module memory, Instruction calldata, bytes calldata) internal pure {\n\t\tuint32 selector = Values.assumeI32(ValueStacks.pop(mach.valueStack));\n\t\tValue memory b = ValueStacks.pop(mach.valueStack);\n\t\tValue memory a = ValueStacks.pop(mach.valueStack);\n\n\t\tif (selector != 0) {\n\t\t\tValueStacks.push(mach.valueStack, a);\n\t\t} else {\n\t\t\tValueStacks.push(mach.valueStack, b);\n\t\t}\n\t}\n\n\tfunction executeBlock(Machine memory mach, Module memory, Instruction calldata inst, bytes calldata) internal pure {\n\t\tuint32 targetPc = uint32(inst.argumentData);\n\t\trequire(targetPc == inst.argumentData, \"BAD_BLOCK_PC\");\n\t\tPcStacks.push(mach.blockStack, targetPc);\n\t}\n\n\tfunction executeBranch(Machine memory mach, Module memory, Instruction calldata, bytes calldata) internal pure {\n\t\tmach.functionPc = PcStacks.pop(mach.blockStack);\n\t}\n\n\tfunction executeBranchIf(Machine memory mach, Module memory, Instruction calldata, bytes calldata) internal pure {\n\t\tValue memory cond = ValueStacks.pop(mach.valueStack);\n\t\tif (cond.contents != 0) {\n\t\t\t// Jump to target\n\t\t\tmach.functionPc = PcStacks.pop(mach.blockStack);\n\t\t}\n\t}\n\n\tfunction executeReturn(Machine memory mach, Module memory, Instruction calldata, bytes calldata) internal pure {\n\t\tStackFrame memory frame = StackFrames.pop(mach.frameStack);\n\t\tif (frame.returnPc.valueType == ValueType.REF_NULL) {\n\t\t\tmach.status = MachineStatus.ERRORED;\n\t\t\treturn;\n\t\t} else if (frame.returnPc.valueType != ValueType.INTERNAL_REF) {\n\t\t\trevert(\"INVALID_RETURN_PC_TYPE\");\n\t\t}\n\t\tuint256 data = frame.returnPc.contents;\n\t\tuint32 pc = uint32(data);\n\t\tuint32 func = uint32(data >> 32);\n\t\tuint32 mod = uint32(data >> 64);\n\t\trequire(data >> 96 == 0, \"INVALID_RETURN_PC_DATA\");\n\t\tmach.functionPc = pc;\n\t\tmach.functionIdx = func;\n\t\tmach.moduleIdx = mod;\n\t}\n\n\tfunction createReturnValue(Machine memory mach) internal pure returns (Value memory) {\n\t\tuint256 returnData = 0;\n\t\treturnData |= mach.functionPc;\n\t\treturnData |= uint256(mach.functionIdx) << 32;\n\t\treturnData |= uint256(mach.moduleIdx) << 64;\n\t\treturn Value({\n\t\t\tvalueType: ValueType.INTERNAL_REF,\n\t\t\tcontents: returnData\n\t\t});\n\t}\n\n\tfunction executeCall(Machine memory mach, Module memory, Instruction calldata inst, bytes calldata) internal pure {\n\t\t// Push the return pc to the stack\n\t\tValueStacks.push(mach.valueStack, createReturnValue(mach));\n\n\t\t// Push caller module info to the stack\n\t\tStackFrame memory frame = StackFrames.peek(mach.frameStack);\n\t\tValueStacks.push(mach.valueStack, Values.newI32(frame.callerModule));\n\t\tValueStacks.push(mach.valueStack, Values.newI32(frame.callerModuleInternals));\n\n\t\t// Jump to the target\n\t\tuint32 idx = uint32(inst.argumentData);\n\t\trequire(idx == inst.argumentData, \"BAD_CALL_DATA\");\n\t\tmach.functionIdx = idx;\n\t\tmach.functionPc = 0;\n\t}\n\n\tfunction executeCrossModuleCall(Machine memory mach, Module memory mod, Instruction calldata inst, bytes calldata) internal pure {\n\t\t// Push the return pc to the stack\n\t\tValueStacks.push(mach.valueStack, createReturnValue(mach));\n\n\t\t// Push caller module info to the stack\n\t\tValueStacks.push(mach.valueStack, Values.newI32(mach.moduleIdx));\n\t\tValueStacks.push(mach.valueStack, Values.newI32(mod.internalsOffset));\n\n\t\t// Jump to the target\n\t\tuint32 func = uint32(inst.argumentData);\n\t\tuint32 module = uint32(inst.argumentData >> 32);\n\t\trequire(inst.argumentData >> 64 == 0, \"BAD_CROSS_MODULE_CALL_DATA\");\n\t\tmach.moduleIdx = module;\n\t\tmach.functionIdx = func;\n\t\tmach.functionPc = 0;\n\t}\n\n\tfunction executeCallerModuleInternalCall(Machine memory mach, Module memory mod, Instruction calldata inst, bytes calldata) internal pure {\n\t\t// Push the return pc to the stack\n\t\tValueStacks.push(mach.valueStack, createReturnValue(mach));\n\n\t\t// Push caller module info to the stack\n\t\tValueStacks.push(mach.valueStack, Values.newI32(mach.moduleIdx));\n\t\tValueStacks.push(mach.valueStack, Values.newI32(mod.internalsOffset));\n\n\t\tStackFrame memory frame = StackFrames.peek(mach.frameStack);\n\t\tif (frame.callerModuleInternals == 0) {\n\t\t\t// The caller module has no internals\n\t\t\tmach.status = MachineStatus.ERRORED;\n\t\t\treturn;\n\t\t}\n\n\t\t// Jump to the target\n\t\tuint32 offset = uint32(inst.argumentData);\n\t\trequire(offset == inst.argumentData, \"BAD_CALLER_INTERNAL_CALL_DATA\");\n\t\tmach.moduleIdx = frame.callerModule;\n\t\tmach.functionIdx = frame.callerModuleInternals + offset;\n\t\tmach.functionPc = 0;\n\t}\n\n\tfunction executeCallIndirect(Machine memory mach, Module memory mod, Instruction calldata inst, bytes calldata proof) internal pure {\n\t\tuint32 funcIdx;\n\t\t{\n\t\t\tuint32 elementIdx = Values.assumeI32(ValueStacks.pop(mach.valueStack));\n\n\t\t\t// Prove metadata about the instruction and tables\n\t\t\tbytes32 elemsRoot;\n\t\t\tbytes32 wantedFuncTypeHash;\n\t\t\tuint256 offset = 0;\n\t\t\t{\n\t\t\t\tuint64 tableIdx;\n\t\t\t\tuint8 tableType;\n\t\t\t\tuint64 tableSize;\n\t\t\t\tMerkleProof memory tableMerkleProof;\n\t\t\t\t(tableIdx, offset) = Deserialize.u64(proof, offset);\n\t\t\t\t(wantedFuncTypeHash, offset) = Deserialize.b32(proof, offset);\n\t\t\t\t(tableType, offset) = Deserialize.u8(proof, offset);\n\t\t\t\t(tableSize, offset) = Deserialize.u64(proof, offset);\n\t\t\t\t(elemsRoot, offset) = Deserialize.b32(proof, offset);\n\t\t\t\t(tableMerkleProof, offset) = Deserialize.merkleProof(proof, offset);\n\n\t\t\t\t// Validate the information by recomputing known hashes\n\t\t\t\tbytes32 recomputed = keccak256(abi.encodePacked(\"Call indirect:\", tableIdx, wantedFuncTypeHash));\n\t\t\t\trequire(recomputed == bytes32(inst.argumentData), \"BAD_CALL_INDIRECT_DATA\");\n\t\t\t\trecomputed = MerkleProofs.computeRootFromTable(tableMerkleProof, tableIdx, tableType, tableSize, elemsRoot);\n\t\t\t\trequire(recomputed == mod.tablesMerkleRoot, \"BAD_TABLES_ROOT\");\n\n\t\t\t\t// Check if the table access is out of bounds\n\t\t\t\tif (elementIdx >= tableSize) {\n\t\t\t\t\tmach.status = MachineStatus.ERRORED;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbytes32 elemFuncTypeHash;\n\t\t\tValue memory functionPointer;\n\t\t\tMerkleProof memory elementMerkleProof;\n\t\t\t(elemFuncTypeHash, offset) = Deserialize.b32(proof, offset);\n\t\t\t(functionPointer, offset) = Deserialize.value(proof, offset);\n\t\t\t(elementMerkleProof, offset) = Deserialize.merkleProof(proof, offset);\n\t\t\tbytes32 recomputedElemRoot = MerkleProofs.computeRootFromElement(elementMerkleProof, elementIdx, elemFuncTypeHash, functionPointer);\n\t\t\trequire(recomputedElemRoot == elemsRoot, \"BAD_ELEMENTS_ROOT\");\n\n\t\t\tif (elemFuncTypeHash != wantedFuncTypeHash) {\n\t\t\t\tmach.status = MachineStatus.ERRORED;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (functionPointer.valueType == ValueType.REF_NULL) {\n\t\t\t\tmach.status = MachineStatus.ERRORED;\n\t\t\t\treturn;\n\t\t\t} else if (functionPointer.valueType == ValueType.FUNC_REF) {\n\t\t\t\tfuncIdx = uint32(functionPointer.contents);\n\t\t\t\trequire(funcIdx == functionPointer.contents, \"BAD_FUNC_REF_CONTENTS\");\n\t\t\t} else {\n\t\t\t\trevert(\"BAD_ELEM_TYPE\");\n\t\t\t}\n\t\t}\n\n\t\t// Push the return pc to the stack\n\t\tValueStacks.push(mach.valueStack, createReturnValue(mach));\n\n\t\t// Push caller module info to the stack\n\t\tStackFrame memory frame = StackFrames.peek(mach.frameStack);\n\t\tValueStacks.push(mach.valueStack, Values.newI32(frame.callerModule));\n\t\tValueStacks.push(mach.valueStack, Values.newI32(frame.callerModuleInternals));\n\n\t\t// Jump to the target\n\t\tmach.functionIdx = funcIdx;\n\t\tmach.functionPc = 0;\n\t}\n\n\tfunction executeArbitraryJumpIf(Machine memory mach, Module memory, Instruction calldata inst, bytes calldata) internal pure {\n\t\tValue memory cond = ValueStacks.pop(mach.valueStack);\n\t\tif (cond.contents != 0) {\n\t\t\t// Jump to target\n\t\t\tuint32 pc = uint32(inst.argumentData);\n\t\t\trequire(pc == inst.argumentData, \"BAD_CALL_DATA\");\n\t\t\tmach.functionPc = pc;\n\t\t}\n\t}\n\n\tfunction merkleProveGetValue(bytes32 merkleRoot, uint256 index, bytes calldata proof) internal pure returns (Value memory) {\n\t\tuint256 offset = 0;\n\t\tValue memory proposedVal;\n\t\tMerkleProof memory merkle;\n\t\t(proposedVal, offset) = Deserialize.value(proof, offset);\n\t\t(merkle, offset) = Deserialize.merkleProof(proof, offset);\n\t\tbytes32 recomputedRoot = MerkleProofs.computeRootFromValue(merkle, index, proposedVal);\n\t\trequire(recomputedRoot == merkleRoot, \"WRONG_MERKLE_ROOT\");\n\t\treturn proposedVal;\n\t}\n\n\tfunction merkleProveSetValue(bytes32 merkleRoot, uint256 index, Value memory newVal, bytes calldata proof) internal pure returns (bytes32) {\n\t\tValue memory oldVal;\n\t\tuint256 offset = 0;\n\t\tMerkleProof memory merkle;\n\t\t(oldVal, offset) = Deserialize.value(proof, offset);\n\t\t(merkle, offset) = Deserialize.merkleProof(proof, offset);\n\t\tbytes32 recomputedRoot = MerkleProofs.computeRootFromValue(merkle, index, oldVal);\n\t\trequire(recomputedRoot == merkleRoot, \"WRONG_MERKLE_ROOT\");\n\t\treturn MerkleProofs.computeRootFromValue(merkle, index, newVal);\n\t}\n\n\tfunction executeLocalGet(Machine memory mach, Module memory, Instruction calldata inst, bytes calldata proof) internal pure {\n\t\tStackFrame memory frame = StackFrames.peek(mach.frameStack);\n\t\tValue memory val = merkleProveGetValue(frame.localsMerkleRoot, inst.argumentData, proof);\n\t\tValueStacks.push(mach.valueStack, val);\n\t}\n\n\tfunction executeLocalSet(Machine memory mach, Module memory, Instruction calldata inst, bytes calldata proof) internal pure {\n\t\tValue memory newVal = ValueStacks.pop(mach.valueStack);\n\t\tStackFrame memory frame = StackFrames.peek(mach.frameStack);\n\t\tframe.localsMerkleRoot = merkleProveSetValue(frame.localsMerkleRoot, inst.argumentData, newVal, proof);\n\t}\n\n\tfunction executeGlobalGet(Machine memory mach, Module memory mod, Instruction calldata inst, bytes calldata proof) internal pure {\n\t\tValue memory val = merkleProveGetValue(mod.globalsMerkleRoot, inst.argumentData, proof);\n\t\tValueStacks.push(mach.valueStack, val);\n\t}\n\n\tfunction executeGlobalSet(Machine memory mach, Module memory mod, Instruction calldata inst, bytes calldata proof) internal pure {\n\t\tValue memory newVal = ValueStacks.pop(mach.valueStack);\n\t\tmod.globalsMerkleRoot = merkleProveSetValue(mod.globalsMerkleRoot, inst.argumentData, newVal, proof);\n\t}\n\n\tfunction executeEndBlock(Machine memory mach, Module memory, Instruction calldata, bytes calldata) internal pure {\n\t\tPcStacks.pop(mach.blockStack);\n\t}\n\n\tfunction executeEndBlockIf(Machine memory mach, Module memory, Instruction calldata, bytes calldata) internal pure {\n\t\tValue memory cond = ValueStacks.peek(mach.valueStack);\n\t\tif (cond.contents != 0) {\n\t\t\tPcStacks.pop(mach.blockStack);\n\t\t}\n\t}\n\n\tfunction executeInitFrame(Machine memory mach, Module memory, Instruction calldata inst, bytes calldata) internal pure {\n\t\tValue memory callerModuleInternals = ValueStacks.pop(mach.valueStack);\n\t\tValue memory callerModule = ValueStacks.pop(mach.valueStack);\n\t\tValue memory returnPc = ValueStacks.pop(mach.valueStack);\n\t\tStackFrame memory newFrame = StackFrame({\n\t\t\treturnPc: returnPc,\n\t\t\tlocalsMerkleRoot: bytes32(inst.argumentData),\n\t\t\tcallerModule: Values.assumeI32(callerModule),\n\t\t\tcallerModuleInternals: Values.assumeI32(callerModuleInternals)\n\t\t});\n\t\tStackFrames.push(mach.frameStack, newFrame);\n\t}\n\n\tfunction executeMoveInternal(Machine memory mach, Module memory, Instruction calldata inst, bytes calldata) internal pure {\n\t\tValue memory val;\n\t\tif (inst.opcode == Instructions.MOVE_FROM_STACK_TO_INTERNAL) {\n\t\t\tval = ValueStacks.pop(mach.valueStack);\n\t\t\tValueStacks.push(mach.internalStack, val);\n\t\t} else if (inst.opcode == Instructions.MOVE_FROM_INTERNAL_TO_STACK) {\n\t\t\tval = ValueStacks.pop(mach.internalStack);\n\t\t\tValueStacks.push(mach.valueStack, val);\n\t\t} else {\n\t\t\trevert(\"MOVE_INTERNAL_INVALID_OPCODE\");\n\t\t}\n\t}\n\n\tfunction executeIsStackBoundary(Machine memory mach, Module memory, Instruction calldata, bytes calldata) internal pure {\n\t\tValue memory val = ValueStacks.pop(mach.valueStack);\n\t\tuint256 newContents = 0;\n\t\tif (val.valueType == ValueType.STACK_BOUNDARY) {\n\t\t\tnewContents = 1;\n\t\t}\n\t\tValueStacks.push(mach.valueStack, Value({\n\t\t\tvalueType: ValueType.I32,\n\t\t\tcontents: newContents\n\t\t}));\n\t}\n\n\tfunction executeDup(Machine memory mach, Module memory, Instruction calldata, bytes calldata) internal pure {\n\t\tValue memory val = ValueStacks.peek(mach.valueStack);\n\t\tValueStacks.push(mach.valueStack, val);\n\t}\n\n\tfunction handleTrap(Machine memory mach) internal pure {\n\t\tmach.status = MachineStatus.ERRORED;\n\t}\n\n\tfunction executeOneStep(ExecutionContext calldata, Machine calldata startMach, Module calldata startMod, Instruction calldata inst, bytes calldata proof) override pure external returns (Machine memory mach, Module memory mod) {\n\t\tmach = startMach;\n\t\tmod = startMod;\n\n\t\tuint16 opcode = inst.opcode;\n\n\t\tfunction(Machine memory, Module memory, Instruction calldata, bytes calldata) internal pure impl;\n\t\tif (opcode == Instructions.UNREACHABLE) {\n\t\t\timpl = executeUnreachable;\n\t\t} else if (opcode == Instructions.NOP) {\n\t\t\timpl = executeNop;\n\t\t} else if (opcode == Instructions.BLOCK) {\n\t\t\timpl = executeBlock;\n\t\t} else if (opcode == Instructions.BRANCH) {\n\t\t\timpl = executeBranch;\n\t\t} else if (opcode == Instructions.BRANCH_IF) {\n\t\t\timpl = executeBranchIf;\n\t\t} else if (opcode == Instructions.RETURN) {\n\t\t\timpl = executeReturn;\n\t\t} else if (opcode == Instructions.CALL) {\n\t\t\timpl = executeCall;\n\t\t} else if (opcode == Instructions.CROSS_MODULE_CALL) {\n\t\t\timpl = executeCrossModuleCall;\n\t\t} else if (opcode == Instructions.CALLER_MODULE_INTERNAL_CALL) {\n\t\t\timpl = executeCallerModuleInternalCall;\n\t\t} else if (opcode == Instructions.CALL_INDIRECT) {\n\t\t\timpl = executeCallIndirect;\n\t\t} else if (opcode == Instructions.END_BLOCK) {\n\t\t\timpl = executeEndBlock;\n\t\t} else if (opcode == Instructions.END_BLOCK_IF) {\n\t\t\timpl = executeEndBlockIf;\n\t\t} else if (opcode == Instructions.ARBITRARY_JUMP_IF) {\n\t\t\timpl = executeArbitraryJumpIf;\n\t\t} else if (opcode == Instructions.LOCAL_GET) {\n\t\t\timpl = executeLocalGet;\n\t\t} else if (opcode == Instructions.LOCAL_SET) {\n\t\t\timpl = executeLocalSet;\n\t\t} else if (opcode == Instructions.GLOBAL_GET) {\n\t\t\timpl = executeGlobalGet;\n\t\t} else if (opcode == Instructions.GLOBAL_SET) {\n\t\t\timpl = executeGlobalSet;\n\t\t} else if (opcode == Instructions.INIT_FRAME) {\n\t\t\timpl = executeInitFrame;\n\t\t} else if (opcode == Instructions.DROP) {\n\t\t\timpl = executeDrop;\n\t\t} else if (opcode == Instructions.SELECT) {\n\t\t\timpl = executeSelect;\n\t\t} else if (opcode >= Instructions.I32_CONST && opcode <= Instructions.F64_CONST || opcode == Instructions.PUSH_STACK_BOUNDARY) {\n\t\t\timpl = executeConstPush;\n\t\t} else if (opcode == Instructions.MOVE_FROM_STACK_TO_INTERNAL || opcode == Instructions.MOVE_FROM_INTERNAL_TO_STACK) {\n\t\t\timpl = executeMoveInternal;\n\t\t} else if (opcode == Instructions.IS_STACK_BOUNDARY) {\n\t\t\timpl = executeIsStackBoundary;\n\t\t} else if (opcode == Instructions.DUP) {\n\t\t\timpl = executeDup;\n\t\t} else {\n\t\t\trevert(\"INVALID_OPCODE\");\n\t\t}\n\n\t\timpl(mach, mod, inst, proof);\n\t}\n}\n"
    },
    "src/test_helpers/ValueArrayTester.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"../state/ValueArrays.sol\";\n\ncontract ValueArrayTester {\n    function test() external pure {\n        ValueArray memory arr = ValueArray(new Value[](2));\n        require(ValueArrays.length(arr) == 2, \"START_LEN\");\n        ValueArrays.set(arr, 0, Values.newI32(1));\n        ValueArrays.set(arr, 1, Values.newI32(2));\n        ValueArrays.push(arr, Values.newI32(3));\n        require(ValueArrays.length(arr) == 3, \"PUSH_LEN\");\n        for (uint256 i = 0; i < ValueArrays.length(arr); i++) {\n            Value memory val = ValueArrays.get(arr, i);\n            require(val.valueType == ValueType.I32, \"PUSH_VAL_TYPE\");\n            require(val.contents == i + 1, \"PUSH_VAL_CONTENTS\");\n        }\n        Value memory popped = ValueArrays.pop(arr);\n        require(popped.valueType == ValueType.I32, \"POP_RET_TYPE\");\n        require(popped.contents == 3, \"POP_RET_CONTENTS\");\n        require(ValueArrays.length(arr) == 2, \"POP_LEN\");\n        for (uint256 i = 0; i < ValueArrays.length(arr); i++) {\n            Value memory val = ValueArrays.get(arr, i);\n            require(val.valueType == ValueType.I32, \"POP_VAL_TYPE\");\n            require(val.contents == i + 1, \"POP_VAL_CONTENTS\");\n        }\n    }\n}\n"
    },
    "src/precompiles/ArbAddressTable.sol": {
      "content": "pragma solidity >=0.4.21 <0.9.0;\n\n/** @title Precompiled contract that exists in every Arbitrum chain at 0x0000000000000000000000000000000000000066.\n* Allows registering / retrieving addresses at uint indices, saving calldata.\n*/\ninterface ArbAddressTable {\n    /**\n    * @notice Register an address in the address table\n    * @param addr address to register\n    * @return index of the address (existing index, or newly created index if not already registered)\n    */\n    function register(address addr) external returns(uint);\n\n    /**\n    * @param addr address to lookup\n    * @return index of an address in the address table (revert if address isn't in the table)\n    */\n    function lookup(address addr) external view returns(uint);\n\n    /**\n    * @notice Check whether an address exists in the address table\n    * @param addr address to check for presence in table\n    * @return true if address is in table\n    */\n    function addressExists(address addr) external view returns(bool);\n\n    /**\n    * @return size of address table (= first unused index)\n     */\n    function size() external view returns(uint);\n\n    /**\n    * @param index index to lookup address\n    * @return address at a given index in address table (revert if index is beyond end of table)\n    */\n    function lookupIndex(uint index) external view returns(address);\n\n    /**\n    * @notice read a compressed address from a bytes buffer\n    * @param buf bytes buffer containing an address\n    * @param offset offset of target address\n    * @return resulting address and updated offset into the buffer (revert if buffer is too short)\n    */\n    function decompress(bytes calldata buf, uint offset) external view returns(address, uint);\n\n    /**\n    * @notice compress an address and return the result, possibly modifying the compression/decompression state\n    * @param addr address to compress\n    * @return compressed address bytes\n    */\n    function compress(address addr) external returns(bytes memory);\n}\n"
    },
    "src/precompiles/ArbAggregator.sol": {
      "content": "pragma solidity >=0.4.21 <0.9.0;\n\ninterface ArbAggregator {\n    // Get the preferred aggregator for an address.\n    // Returns (preferredAggregatorAddress, isDefault)\n    //     isDefault is true if addr is set to prefer the default aggregator\n    function getPreferredAggregator(address addr) external view returns (address, bool);\n\n    // Set the caller's preferred aggregator.\n    // If prefAgg is zero, this sets the caller to prefer the default aggregator\n    function setPreferredAggregator(address prefAgg) external;\n\n    // Get default aggregator.\n    function getDefaultAggregator() external view returns (address);\n\n    // Set the preferred aggregator.\n    // Reverts unless called by the chain owner or the current default aggregator.\n    function setDefaultAggregator(address newDefault) external;\n\n    // Get the address where fees to aggregator are sent.\n    // This will often but not always be the same as the aggregator's address.\n    function getFeeCollector(address aggregator) external view returns (address);\n\n    // Set the address where fees to aggregator are sent.\n    // This reverts unless called by the address that would be returned by getFeeCollector(aggregator),\n    //      or by the chain owner.\n    function setFeeCollector(address aggregator, address newFeeCollector) external;\n\n    // Get the tx base fee (in approximate L1 gas) for aggregator\n    function getTxBaseFee(address aggregator) external view returns (uint);\n\n    // Set the tx base fee (in approximate L1 gas) for aggregator\n    // Revert unless called by aggregator or the chain owner\n    // Revert if feeInL1Gas is outside the chain's allowed bounds\n    function setTxBaseFee(address aggregator, uint feeInL1Gas) external;\n}\n"
    },
    "src/precompiles/ArbBLS.sol": {
      "content": "pragma solidity >=0.4.21 <0.9.0;\n\n//This functionality has been disabled for now.  Calls to these methods will revert.\ninterface ArbBLS {\n    // Associate a BLS public key with the caller's address\n    function register(uint x0, uint x1, uint y0, uint y1) external;\n\n    // Get the BLS public key associated with an address (revert if there isn't one)\n    function getPublicKey(address addr) external view returns (uint, uint, uint, uint);\n}\n"
    },
    "src/precompiles/ArbDebug.sol": {
      "content": "\npragma solidity >=0.4.21 <0.9.0;\n\n/**\n* @title A test contract\n*/\ninterface ArbDebug {\n    event Basic(bool flag, bytes32 indexed value);\n    event Mixed(bool indexed flag, bool not, bytes32 indexed value, address conn, address indexed caller);\n    event Store(bool indexed flag, address indexed field, uint24 number, bytes32 value, bytes store);\n\n    function events(bool flag, bytes32 value) external payable returns(address, uint256);\n}\n"
    },
    "src/precompiles/ArbFunctionTable.sol": {
      "content": "pragma solidity >=0.4.21 <0.9.0;\n\ninterface ArbFunctionTable {\n    // Upload a serialized function table and associate it with the caller's address\n    // If caller already had a function table, this will overwrite the old one\n    // Revert if buf is mal-formatted\n    // (Caller will typically be an aggregator)\n    function upload(bytes calldata buf) external;\n\n    // Get the size of addr's function table; revert if addr doesn't have a function table\n    function size(address addr) external view returns(uint);\n\n    // Get the entry from addr's function table, at index; revert if addr has no table or index out of bounds\n    // Returns (functionCode, isPayable, gasLimit)\n    function get(address addr, uint index) external view returns(uint, bool, uint);\n}\n"
    },
    "src/precompiles/ArbGasInfo.sol": {
      "content": "pragma solidity >=0.4.21 <0.9.0;\n\ninterface ArbGasInfo {\n    // return gas prices in wei, assuming the specified aggregator is used\n    //        (\n    //            per L2 tx,\n    //            per L1 calldata unit, (zero byte = 4 units, nonzero byte = 16 units)\n    //            per storage allocation,\n    //            per ArbGas base,\n    //            per ArbGas congestion,\n    //            per ArbGas total\n    //        )\n    function getPricesInWeiWithAggregator(address aggregator) external view returns (uint, uint, uint, uint, uint, uint);\n\n    // return gas prices in wei, as described above, assuming the caller's preferred aggregator is used\n    //     if the caller hasn't specified a preferred aggregator, the default aggregator is assumed\n    function getPricesInWei() external view returns (uint, uint, uint, uint, uint, uint);\n\n    // return prices in ArbGas (per L2 tx, per L1 calldata unit, per storage allocation),\n    //       assuming the specified aggregator is used\n    function getPricesInArbGasWithAggregator(address aggregator) external view returns (uint, uint, uint);\n\n    // return gas prices in ArbGas, as described above, assuming the caller's preferred aggregator is used\n    //     if the caller hasn't specified a preferred aggregator, the default aggregator is assumed\n    function getPricesInArbGas() external view returns (uint, uint, uint);\n\n    // return gas accounting parameters (speedLimitPerSecond, gasPoolMax, maxTxGasLimit)\n    function getGasAccountingParams() external view returns (uint, uint, uint);\n\n    // get ArbOS's estimate of the L1 gas price in wei\n    function getL1GasPriceEstimate() external view returns(uint);\n\n    // set ArbOS's estimate of the L1 gas price in wei\n    // reverts unless called by chain owner or designated gas oracle (if any)\n    function setL1GasPriceEstimate(uint priceInWei) external;\n}\n"
    },
    "src/precompiles/ArbInfo.sol": {
      "content": "/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.2 || <0.9.0;\n\ncontract ArbInfo {\n    function getBalance(address account) external view returns (uint256) {\n        return account.balance;\n    }\n\n    function getCode(address account) external view returns (bytes memory) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        bytes memory code = new bytes(size);\n        assembly {\n            extcodecopy(account, add(code, 0x20), 0, size)\n        }\n        return code;\n    }\n}\n"
    },
    "src/precompiles/ArbosTest.sol": {
      "content": "pragma solidity >=0.4.21 <0.9.0;\n\ninterface ArbosTest {\n    function installAccount(address addr, bool isEOA, uint balance, uint nonce, bytes calldata code, bytes calldata initStorage) external;\n\n    function getMarshalledStorage(address addr) external view;  // returns raw returndata\n\n    function getAccountInfo(address addr) external view;  // returns raw returndata\n\n    function burnArbGas(uint gasAmount) external view;\n\n    function setNonce(address addr, uint nonce) external;\n}\n"
    },
    "src/precompiles/ArbOwner.sol": {
      "content": "pragma solidity >=0.4.21 <0.9.0;\n\ninterface ArbOwner {\n    // Support actions that can be taken by the chain's owner.\n    // All methods will revert, unless the caller is the chain's owner.\n\n    function addChainOwner(address newOwner) external;\n    function removeChainOwner(address ownerToRemove) external;    // revert if ownerToRemove is not an owner\n    function isChainOwner(address addr) external view returns(bool);\n    function getAllChainOwners() external view returns(address[] memory);\n}\n"
    },
    "src/precompiles/ArbRetryableTx.sol": {
      "content": "\npragma solidity >=0.4.21 <0.9.0;\n\n/**\n* @title precompiled contract in every Arbitrum chain for retryable transaction related data retrieval and interactions. Exists at 0x000000000000000000000000000000000000006E\n*/\ninterface ArbRetryableTx {\n\n    /**\n    * @notice Redeem a redeemable tx.\n    * Revert if called by an L2 contract, or if txId does not exist, or if txId reverts.\n    * If this returns, txId has been completed and is no longer available for redemption.\n    * If this reverts, txId is still available for redemption (until it times out or is canceled).\n    @param txId unique identifier of retryable message: keccak256(keccak256(ArbchainId, inbox-sequence-number), uint(0) )\n     */\n    function redeem(bytes32 txId) external;\n\n    /**\n    * @notice Return the minimum lifetime of redeemable txn.\n    * @return lifetime in seconds\n    */\n    function getLifetime() external view returns(uint);\n\n    /**\n    * @notice Return the timestamp when ticketId will age out, or zero if ticketId does not exist.\n    * The timestamp could be in the past, because aged-out tickets might not be discarded immediately.\n    * @param ticketId unique ticket identifier\n    * @return timestamp for ticket's deadline\n    */\n    function getTimeout(bytes32 ticketId) external view returns(uint);\n\n    /**\n    * @notice Return the price, in wei, of submitting a new retryable tx with a given calldata size.\n    * @param calldataSize call data size to get price of (in wei)\n    * @return (price, nextUpdateTimestamp). Price is guaranteed not to change until nextUpdateTimestamp.\n    */\n    function getSubmissionPrice(uint calldataSize) external view returns (uint, uint);\n\n    /**\n     * @notice Return the price, in wei, of extending the lifetime of ticketId by an additional lifetime period. Revert if ticketId doesn't exist.\n     * @param ticketId unique ticket identifier\n     * @return (price, nextUpdateTimestamp). Price is guaranteed not to change until nextUpdateTimestamp.\n    */\n    function getKeepalivePrice(bytes32 ticketId) external view returns(uint, uint);\n\n    /**\n    @notice Deposits callvalue into the sender's L2 account, then adds one lifetime period to the life of ticketId.\n    * If successful, emits LifetimeExtended event.\n    * Revert if ticketId does not exist, or if the timeout of ticketId is already at least one lifetime period in the future, or if the sender has insufficient funds (after the deposit).\n    * @param ticketId unique ticket identifier\n    * @return New timeout of ticketId.\n    */\n    function keepalive(bytes32 ticketId) external payable returns(uint);\n\n    /**\n    * @notice Return the beneficiary of ticketId.\n    * Revert if ticketId doesn't exist.\n    * @param ticketId unique ticket identifier\n    * @return address of beneficiary for ticket\n    */\n    function getBeneficiary(bytes32 ticketId) external view returns (address);\n\n    /**\n    * @notice Cancel ticketId and refund its callvalue to its beneficiary.\n    * Revert if ticketId doesn't exist, or if called by anyone other than ticketId's beneficiary.\n    * @param ticketId unique ticket identifier\n    */\n    function cancel(bytes32 ticketId) external;\n\n    event TicketCreated(bytes32 indexed ticketId);\n    event LifetimeExtended(bytes32 indexed ticketId, uint newTimeout);\n    event Redeemed(bytes32 indexed ticketId);\n    event Canceled(bytes32 indexed ticketId);\n}\n"
    },
    "src/precompiles/ArbStatistics.sol": {
      "content": "\npragma solidity >=0.4.21 <0.9.0;\n\ninterface ArbStatistics {\n    // Get the following statistics for this chain:\n    //      Number of Arbitrum blocks\n    //      Number of accounts\n    //      Total storage allocated (includes storage that was later deallocated)\n    //      Total ArbGas used\n    //      Number of transaction receipt issued\n    //      Number of contracts created\n    function getStats() external view returns(uint, uint, uint, uint, uint, uint);\n}\n"
    },
    "src/precompiles/ArbSys.sol": {
      "content": "/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity >=0.4.21 <0.9.0;\n\n/**\n* @title Precompiled contract that exists in every Arbitrum chain at address(100), 0x0000000000000000000000000000000000000064. Exposes a variety of system-level functionality.\n */\ninterface ArbSys {\n    /**\n    * @notice Get internal version number identifying an ArbOS build\n    * @return version number as int\n     */\n    function arbOSVersion() external pure returns (uint);\n\n    function arbChainID() external view returns(uint);\n\n    /**\n    * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\n    * @return block number as int\n     */\n    function arbBlockNumber() external view returns (uint);\n\n    /**\n    * @notice Send given amount of Eth to dest from sender.\n    * This is a convenience function, which is equivalent to calling sendTxToL1 with empty calldataForL1.\n    * @param destination recipient address on L1\n    * @return unique identifier for this L2-to-L1 transaction.\n    */\n    function withdrawEth(address destination) external payable returns(uint);\n\n    /**\n    * @notice Send a transaction to L1\n    * @param destination recipient address on L1\n    * @param calldataForL1 (optional) calldata for L1 contract call\n    * @return a unique identifier for this L2-to-L1 transaction.\n    */\n    function sendTxToL1(address destination, bytes calldata calldataForL1) external payable returns(uint);\n\n    /**\n    * @notice Get send Merkle tree state\n    * @return size number of sends in the history\n    * @return root root hash of the send history\n    * @return partials hashes of partial subtrees in the send history tree\n    */\n    function sendMerkleTreeState() external view returns(uint size, bytes32 root, bytes32[] memory partials);\n\n    /**\n    * @notice get the number of transactions issued by the given external account or the account sequence number of the given contract\n    * @param account target account\n    * @return the number of transactions issued by the given external account or the account sequence number of the given contract\n    */\n    function getTransactionCount(address account) external view returns(uint256);\n\n    /**\n    * @notice get the value of target L2 storage slot\n    * This function is only callable from address 0 to prevent contracts from being able to call it\n    * @param account target account\n    * @param index target index of storage slot\n    * @return stotage value for the given account at the given index\n    */\n    function getStorageAt(address account, uint256 index) external view returns (uint256);\n\n    /**\n    * @notice check if current call is coming from l1\n    * @return true if the caller of this was called directly from L1\n    */\n    function isTopLevelCall() external view returns (bool);\n\n    /**\n     * @notice check if the caller (of this caller of this) is an aliased L1 contract address\n     * @return true iff the caller's address is an alias for an L1 contract address\n     */\n    function wasMyCallersAddressAliased() external view returns (bool);\n\n    /**\n     * @notice return the address of the caller (of this caller of this), without applying L1 contract address aliasing\n     * @return address of the caller's caller, without applying L1 contract address aliasing\n     */\n    function myCallersAddressWithoutAliasing() external view returns (address);\n\n    /**\n     * @notice map L1 sender contract address to its L2 alias\n     * @param sender sender address\n     * @param dest destination address\n     * @return aliased sender address\n     */\n    function mapL1SenderContractAddressToL2Alias(address sender, address dest) external pure returns(address);\n\n    /**\n     * @notice get the caller's amount of available storage gas\n     * @return amount of storage gas available to the caller\n     */\n    function getStorageGasAvailable() external returns(uint);\n\n    /**\n     * @notice creates a send txn from L2 to L1\n     * @param position = (level << 192) + leaf = (0 << 192) + leaf = leaf\n    */\n    event L2ToL1Transaction(\n        address caller,\n        address indexed destination,\n        uint indexed hash,\n        uint indexed position,\n        uint indexInBatch,\n        uint arbBlockNum,\n        uint ethBlockNum,\n        uint timestamp,\n        uint callvalue,\n        bytes data\n    );\n\n    /**\n     * @notice logs a merkle branch for proof sythesis\n     * @param reserved an index meant only to align the 4th index with L2ToL1Transaction's 4th event\n     * @param hash the merkle hash\n     * @param position = (level << 192) + leaf\n    */\n    event SendMerkleUpdate(\n        uint indexed reserved,\n        bytes32 indexed hash,\n        uint indexed position\n    );\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}